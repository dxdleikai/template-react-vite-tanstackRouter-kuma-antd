{
  "version": 3,
  "sources": ["../../.pnpm/@tanstack+history@1.28.9/node_modules/@tanstack/history/src/index.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/routerContext.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/useRouter.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/CatchBoundary.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/useRouterState.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/utils.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/not-found.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/redirects.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/Matches.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/path.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/useParams.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/useSearch.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/useNavigate.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/route.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/qss.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/searchParams.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/RouterProvider.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/router.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/defer.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/awaited.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/fileRoute.ts", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/lazyRouteComponent.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/link.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/scroll-restoration.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/useBlocker.tsx", "../../.pnpm/@tanstack+react-router@1.31.1_react-dom@18.3.1_react@18.3.1/node_modules/@tanstack/react-router/src/useRouteContext.ts"],
  "sourcesContent": ["// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: HistoryLocation\n  subscribe: (cb: () => void) => () => void\n  push: (path: string, state?: any) => void\n  replace: (path: string, state?: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blocker: BlockerFn) => () => void\n  flush: () => void\n  destroy: () => void\n  notify: () => void\n}\n\nexport interface HistoryLocation extends ParsedPath {\n  state: HistoryState\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface HistoryState {\n  key?: string\n}\n\ntype ShouldAllowNavigation = any\n\nexport type BlockerFn = () =>\n  | Promise<ShouldAllowNavigation>\n  | ShouldAllowNavigation\n\nconst pushStateEvent = 'pushstate'\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nexport function createHistory(opts: {\n  getLocation: () => HistoryLocation\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n  flush?: () => void\n  destroy?: () => void\n  onBlocked?: (onUpdate: () => void) => void\n}): RouterHistory {\n  let location = opts.getLocation()\n  const subscribers = new Set<() => void>()\n  let blockers: Array<BlockerFn> = []\n\n  const notify = () => {\n    location = opts.getLocation()\n    subscribers.forEach((subscriber) => subscriber())\n  }\n\n  const tryNavigation = async (task: () => void) => {\n    if (typeof document !== 'undefined' && blockers.length) {\n      for (const blocker of blockers) {\n        const allowed = await blocker()\n        if (!allowed) {\n          opts.onBlocked?.(notify)\n          return\n        }\n      }\n    }\n\n    task()\n  }\n\n  return {\n    get location() {\n      return location\n    },\n    subscribe: (cb: () => void) => {\n      subscribers.add(cb)\n\n      return () => {\n        subscribers.delete(cb)\n      }\n    },\n    push: (path: string, state: any) => {\n      state = assignKey(state)\n      tryNavigation(() => {\n        opts.pushState(path, state)\n        notify()\n      })\n    },\n    replace: (path: string, state: any) => {\n      state = assignKey(state)\n      tryNavigation(() => {\n        opts.replaceState(path, state)\n        notify()\n      })\n    },\n    go: (index) => {\n      tryNavigation(() => {\n        opts.go(index)\n        notify()\n      })\n    },\n    back: () => {\n      tryNavigation(() => {\n        opts.back()\n        notify()\n      })\n    },\n    forward: () => {\n      tryNavigation(() => {\n        opts.forward()\n        notify()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (blocker) => {\n      blockers.push(blocker)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== blocker)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify,\n  }\n}\n\nfunction assignKey(state: HistoryState | undefined) {\n  if (!state) {\n    state = {} as HistoryState\n  }\n  return {\n    ...state,\n    key: createRandomKey(),\n  }\n}\n\n/**\n * Creates a history object that can be used to interact with the browser's\n * navigation. This is a lightweight API wrapping the browser's native methods.\n * It is designed to work with TanStack Router, but could be used as a standalone API as well.\n * IMPORTANT: This API implements history throttling via a microtask to prevent\n * excessive calls to the history API. In some browsers, calling history.pushState or\n * history.replaceState in quick succession can cause the browser to ignore subsequent\n * calls. This API smooths out those differences and ensures that your application\n * state will *eventually* match the browser state. In most cases, this is not a problem,\n * but if you need to ensure that the browser state is up to date, you can use the\n * `history.flush` method to immediately flush all pending state changes to the browser URL.\n * @param opts\n * @param opts.getHref A function that returns the current href (path + search + hash)\n * @param opts.createHref A function that takes a path and returns a href (path + search + hash)\n * @returns A history instance\n */\nexport function createBrowserHistory(opts?: {\n  parseLocation?: () => HistoryLocation\n  createHref?: (path: string) => string\n  window?: any\n}): RouterHistory {\n  const win =\n    opts?.window ??\n    (typeof document !== 'undefined' ? window : (undefined as any))\n\n  const originalPushState = win.history.pushState\n  const originalReplaceState = win.history.replaceState\n\n  const createHref = opts?.createHref ?? ((path) => path)\n  const parseLocation =\n    opts?.parseLocation ??\n    (() =>\n      parseHref(\n        `${win.location.pathname}${win.location.search}${win.location.hash}`,\n        win.history.state,\n      ))\n\n  let currentLocation = parseLocation()\n  let rollbackLocation: HistoryLocation | undefined\n\n  const getLocation = () => currentLocation\n\n  let next:\n    | undefined\n    | {\n        // This is the latest location that we were attempting to push/replace\n        href: string\n        // This is the latest state that we were attempting to push/replace\n        state: any\n        // This is the latest type that we were attempting to push/replace\n        isPush: boolean\n      }\n\n  // We need to track the current scheduled update to prevent\n  // multiple updates from being scheduled at the same time.\n  let scheduled: Promise<void> | undefined\n\n  // This function flushes the next update to the browser history\n  const flush = () => {\n    if (!next) {\n      return\n    }\n\n    // We use the original push/replace calls here to ensure that\n    // we do not notify subscribers about this push/replace call\n    const caller = next.isPush ? originalPushState : originalReplaceState\n    caller.call(win.history, next.state, '', next.href)\n    // Reset the nextIsPush flag and clear the scheduled update\n    next = undefined\n    scheduled = undefined\n    rollbackLocation = undefined\n  }\n\n  // This function queues up a call to update the browser history\n  const queueHistoryAction = (\n    type: 'push' | 'replace',\n    destHref: string,\n    state: any,\n  ) => {\n    const href = createHref(destHref)\n\n    if (!scheduled) {\n      rollbackLocation = currentLocation\n    }\n\n    // Update the location in memory\n    currentLocation = parseHref(destHref, state)\n\n    // Keep track of the next location we need to flush to the URL\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === 'push',\n    }\n\n    if (!scheduled) {\n      // Schedule an update to the browser history\n      scheduled = Promise.resolve().then(() => flush())\n    }\n  }\n\n  const onPushPop = () => {\n    currentLocation = parseLocation()\n    history.notify()\n  }\n\n  const history = createHistory({\n    getLocation,\n    pushState: (href, state) => queueHistoryAction('push', href, state),\n    replaceState: (href, state) => queueHistoryAction('replace', href, state),\n    back: () => win.history.back(),\n    forward: () => win.history.forward(),\n    go: (n) => win.history.go(n),\n    createHref: (href) => createHref(href),\n    flush,\n    destroy: () => {\n      win.history.pushState = originalPushState\n      win.history.replaceState = originalReplaceState\n      win.removeEventListener(pushStateEvent, onPushPop)\n      win.removeEventListener(popStateEvent, onPushPop)\n    },\n    onBlocked: (onUpdate) => {\n      // If a navigation is blocked, we need to rollback the location\n      // that we optimistically updated in memory.\n      if (rollbackLocation && currentLocation !== rollbackLocation) {\n        currentLocation = rollbackLocation\n        // Notify subscribers\n        onUpdate()\n      }\n    },\n  })\n\n  win.addEventListener(pushStateEvent, onPushPop)\n  win.addEventListener(popStateEvent, onPushPop)\n\n  win.history.pushState = function (...args: Array<any>) {\n    const res = originalPushState.apply(win.history, args)\n    onPushPop()\n    return res\n  }\n\n  win.history.replaceState = function (...args: Array<any>) {\n    const res = originalReplaceState.apply(win.history, args)\n    onPushPop()\n    return res\n  }\n\n  return history\n}\n\nexport function createHashHistory(opts?: { window?: any }): RouterHistory {\n  const win =\n    opts?.window ??\n    (typeof document !== 'undefined' ? window : (undefined as any))\n  return createBrowserHistory({\n    window: win,\n    parseLocation: () => {\n      const hashHref = win.location.hash.split('#').slice(1).join('#') ?? '/'\n      return parseHref(hashHref, win.history.state)\n    },\n    createHref: (href) =>\n      `${win.location.pathname}${win.location.search}#${href}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: Array<string>\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {\n    key: createRandomKey(),\n  } as HistoryState\n\n  const getLocation = () => parseHref(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n\n    pushState: (path, state) => {\n      currentState = state\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = state\n      entries[index] = path\n    },\n    back: () => {\n      currentState = assignKey(currentState)\n      index--\n    },\n    forward: () => {\n      currentState = assignKey(currentState)\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => {\n      currentState = assignKey(currentState)\n      index = Math.min(Math.max(index + n, 0), entries.length - 1)\n    },\n    createHref: (path) => path,\n  })\n}\n\nfunction parseHref(\n  href: string,\n  state: HistoryState | undefined,\n): HistoryLocation {\n  const hashIndex = href.indexOf('#')\n  const searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n          ? searchIndex\n          : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search:\n      searchIndex > -1\n        ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex)\n        : '',\n    state: state || {},\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n", "import * as React from 'react'\nimport type { Router } from './router'\n\nconst routerContext = React.createContext<Router<any, any>>(null!)\n\nexport function getRouterContext() {\n  if (typeof document === 'undefined') {\n    return routerContext\n  }\n\n  if (window.__TSR_ROUTER_CONTEXT__) {\n    return window.__TSR_ROUTER_CONTEXT__\n  }\n\n  window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n\n  return routerContext\n}\n", "import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { getRouterContext } from './routerContext'\nimport type { AnyRouter, RegisteredRouter, Router } from './router'\n\nexport function useRouter<TRouter extends AnyRouter = RegisteredRouter>(opts?: {\n  warn?: boolean\n}): TRouter {\n  const value = React.useContext(getRouterContext())\n  warning(\n    !((opts?.warn ?? true) && !value),\n    'useRouter must be used inside a <RouterProvider> component!',\n  )\n  return value as any\n}\n", "import * as React from 'react'\n\nexport function CatchBoundary(props: {\n  getResetKey: () => string\n  children: any\n  errorComponent?: any\n  onCatch?: (error: any) => void\n}) {\n  const errorComponent = props.errorComponent ?? ErrorComponent\n\n  return (\n    <CatchBoundaryImpl\n      getResetKey={props.getResetKey}\n      onCatch={props.onCatch}\n      children={({ error, reset }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n            reset,\n          })\n        }\n\n        return props.children\n      }}\n    />\n  )\n}\n\nclass CatchBoundaryImpl extends React.Component<{\n  getResetKey: () => string\n  children: (props: { error: any; reset: () => void }) => any\n  onCatch?: (error: any) => void\n}> {\n  state = { error: null } as { error: any; resetKey: string }\n  static getDerivedStateFromProps(props: any) {\n    return { resetKey: props.getResetKey() }\n  }\n  static getDerivedStateFromError(error: any) {\n    return { error }\n  }\n  reset() {\n    this.setState({ error: null })\n  }\n  componentDidUpdate(\n    prevProps: Readonly<{\n      getResetKey: () => string\n      children: (props: { error: any; reset: () => void }) => any\n      onCatch?: ((error: any, info: any) => void) | undefined\n    }>,\n    prevState: any,\n  ): void {\n    if (prevState.error && prevState.resetKey !== this.state.resetKey) {\n      this.reset()\n    }\n  }\n  componentDidCatch(error: any) {\n    if (this.props.onCatch) {\n      this.props.onCatch(error)\n    } else {\n      console.error(error)\n    }\n  }\n  render() {\n    return this.props.children({\n      error: this.state.error,\n      reset: () => {\n        this.reset()\n      },\n    })\n  }\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production')\n\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>\n        <strong style={{ fontSize: '1rem' }}>Something went wrong!</strong>\n        <button\n          style={{\n            appearance: 'none',\n            fontSize: '.6em',\n            border: '1px solid currentColor',\n            padding: '.1rem .2rem',\n            fontWeight: 'bold',\n            borderRadius: '.25rem',\n          }}\n          onClick={() => setShow((d) => !d)}\n        >\n          {show ? 'Hide Error' : 'Show Error'}\n        </button>\n      </div>\n      <div style={{ height: '.25rem' }} />\n      {show ? (\n        <div>\n          <pre\n            style={{\n              fontSize: '.7em',\n              border: '1px solid red',\n              borderRadius: '.25rem',\n              padding: '.3rem',\n              color: 'red',\n              overflow: 'auto',\n            }}\n          >\n            {error.message ? <code>{error.message}</code> : null}\n          </pre>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n", "import { useStore } from '@tanstack/react-store'\nimport { useRouter } from './useRouter'\nimport type { AnyRouter, RegisteredRouter, Router, RouterState } from './router'\n\nexport function useRouterState<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = RouterState<TRouter['routeTree']>,\n>(opts?: {\n  router?: TRouter\n  select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected\n}): TSelected {\n  const contextRouter = useRouter<TRouter>({\n    warn: opts?.router === undefined,\n  })\n  return useStore((opts?.router || contextRouter).__store, opts?.select as any)\n}\n", "import * as React from 'react'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<TValue, TYesResult, TNoResult = TValue> = 1 extends 0 & TValue\n  ? TYesResult\n  : TNoResult\nexport type PickAsRequired<TValue, TKey extends keyof TValue> = Omit<\n  TValue,\n  TKey\n> &\n  Required<Pick<TValue, TKey>>\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\n// from https://stackoverflow.com/a/76458160\nexport type WithoutEmpty<T> = T extends any ? ({} extends T ? never : T) : never\n\n// export type Expand<T> = T\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? O extends Function\n      ? O\n      : { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<T> = (\n  T extends any ? (k: T) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\nexport type DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>\n    }\n  : T\n\nexport type MakeDifferenceOptional<TLeft, TRight> = Omit<\n  TRight,\n  keyof TLeft\n> & {\n  [K in keyof TLeft & keyof TRight]?: TRight[K]\n}\n\n// from https://stackoverflow.com/a/53955431\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport type IsUnion<T, U extends T = T> = (\n  T extends any ? (U extends T ? false : true) : never\n) extends false\n  ? false\n  : true\n\nexport type Assign<TLeft, TRight> = keyof TLeft extends never\n  ? TRight\n  : keyof TRight extends never\n    ? TLeft\n    : Omit<TLeft, keyof TRight> & TRight\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type NonNullableUpdater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev: TPrevious) => TResult)\n\n// from https://github.com/type-challenges/type-challenges/issues/737\ntype LastInUnion<T> =\n  UnionToIntersection<T extends unknown ? (x: T) => 0 : never> extends (\n    x: infer L,\n  ) => 0\n    ? L\n    : never\nexport type UnionToTuple<T, TLast = LastInUnion<T>> = [T] extends [never]\n  ? []\n  : [...UnionToTuple<Exclude<T, TLast>>, TLast]\n\n//\n\nexport function last<T>(arr: Array<T>) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult> | NonNullableUpdater<TResult>,\n  previous: TResult,\n): TResult {\n  if (isFunction(updater)) {\n    return updater(previous)\n  }\n\n  return updater\n}\n\nexport function pick<TValue, TKey extends keyof TValue>(\n  parent: TValue,\n  keys: Array<TKey>,\n): Pick<TValue, TKey> {\n  return keys.reduce((obj: any, key: TKey) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `prev` if `_next` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = isPlainArray(prev) && isPlainArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevItems = array ? prev : Object.keys(prev)\n    const prevSize = prevItems.length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      if (\n        !array &&\n        prev[key] === undefined &&\n        next[key] === undefined &&\n        prevItems.includes(key)\n      ) {\n        copy[key] = undefined\n        equalItems++\n      } else {\n        copy[key] = replaceEqualDeep(prev[key], next[key])\n        if (copy[key] === prev[key] && prev[key] !== undefined) {\n          equalItems++\n        }\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\nexport function deepEqual(a: any, b: any, partial: boolean = false): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n\n    if (!partial && aKeys.length !== bKeys.length) {\n      return false\n    }\n\n    return !bKeys.some(\n      (key) => !(key in a) || !deepEqual(a[key], b[key], partial),\n    )\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return !a.some((item, index) => !deepEqual(item, b[index], partial))\n  }\n\n  return false\n}\n\nexport function useStableCallback<T extends (...args: Array<any>) => any>(\n  fn: T,\n): T {\n  const fnRef = React.useRef(fn)\n  fnRef.current = fn\n\n  const ref = React.useRef((...args: Array<any>) => fnRef.current(...args))\n  return ref.current as T\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (const item of keysA) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, item) ||\n      !Object.is(objA[item as keyof T], objB[item as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nexport type StringLiteral<T> = T extends string\n  ? string extends T\n    ? string\n    : T\n  : never\n\nexport type StrictOrFrom<TFrom, TReturnIntersection extends boolean = false> =\n  | {\n      from: StringLiteral<TFrom> | TFrom\n      strict?: true\n    }\n  | {\n      from?: never\n      strict: false\n      experimental_returnIntersection?: TReturnIntersection\n    }\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\n/**\n *\n * @deprecated use `jsesc` instead\n */\nexport function escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n\nexport function removeTrailingSlash(value: string): string {\n  if (value.endsWith('/') && value !== '/') {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\nexport function exactPathTest(pathName1: string, pathName2: string): boolean {\n  return removeTrailingSlash(pathName1) === removeTrailingSlash(pathName2)\n}\n\nexport type ControlledPromise<T> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value: any) => void\n  status: 'pending' | 'resolved' | 'rejected'\n}\n\nexport function createControlledPromise<T>(onResolve?: () => void) {\n  let resolveLoadPromise!: () => void\n  let rejectLoadPromise!: (value: any) => void\n\n  const controlledPromise = new Promise<void>((resolve, reject) => {\n    resolveLoadPromise = resolve\n    rejectLoadPromise = reject\n  }) as ControlledPromise<T>\n\n  controlledPromise.status = 'pending'\n\n  controlledPromise.resolve = () => {\n    controlledPromise.status = 'resolved'\n    resolveLoadPromise()\n    onResolve?.()\n  }\n\n  controlledPromise.reject = (e) => {\n    controlledPromise.status = 'rejected'\n    rejectLoadPromise(e)\n  }\n\n  return controlledPromise\n}\n", "// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nimport * as React from 'react'\nimport { CatchBoundary } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport type { RegisteredRouter } from './router'\nimport type { RouteIds } from './routeInfo'\n\nexport type NotFoundError = {\n  /**\n    @deprecated\n    Use `routeId: rootRouteId` instead\n  */\n  global?: boolean\n  /**\n    @private\n    Do not use this. It's used internally to indicate a path matching error\n  */\n  _global?: boolean\n  data?: any\n  throw?: boolean\n  routeId?: RouteIds<RegisteredRouter['routeTree']>\n  headers?: HeadersInit\n}\n\nexport function notFound(options: NotFoundError = {}) {\n  ;(options as any).isNotFound = true\n  if (options.throw) throw options\n  return options\n}\n\nexport function isNotFound(obj: any): obj is NotFoundError {\n  return !!obj?.isNotFound\n}\n\nexport function CatchNotFound(props: {\n  fallback?: (error: NotFoundError) => React.ReactElement\n  onCatch?: (error: any) => void\n  children: React.ReactNode\n}) {\n  // TODO: Some way for the user to programmatically reset the not-found boundary?\n  const resetKey = useRouterState({\n    select: (s) => `not-found-${s.location.pathname}-${s.status}`,\n  })\n\n  return (\n    <CatchBoundary\n      getResetKey={() => resetKey}\n      onCatch={(error) => {\n        if (isNotFound(error)) {\n          props.onCatch?.(error)\n        } else {\n          throw error\n        }\n      }}\n      errorComponent={({ error }: { error: NotFoundError }) =>\n        props.fallback?.(error)\n      }\n    >\n      {props.children}\n    </CatchBoundary>\n  )\n}\n\nexport function DefaultGlobalNotFound() {\n  return <p>Not Found</p>\n}\n", "import type { NavigateOptions } from './link'\nimport type { AnyRoute } from './route'\nimport type { RoutePaths } from './routeInfo'\nimport type { AnyRouter, RegisteredRouter } from './router'\nimport type { PickAsRequired } from './utils'\n\nexport type AnyRedirect = Redirect<any, any, any, any, any>\n\nexport type Redirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n> = {\n  /**\n   * @deprecated Use `statusCode` instead\n   **/\n  href?: string\n  code?: number\n  statusCode?: number\n  throw?: any\n  headers?: HeadersInit\n} & NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport type ResolvedRedirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n> = PickAsRequired<\n  Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n  'code' | 'statusCode' | 'headers'\n> & {\n  href: string\n}\n\nexport function redirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n): Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> {\n  ;(opts as any).isRedirect = true\n  opts.statusCode = opts.statusCode || opts.code || 301\n  opts.headers = opts.headers || {}\n  if (opts.throw) {\n    throw opts\n  }\n\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n", "import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { createControlledPromise, pick } from './utils'\nimport { CatchNotFound, DefaultGlobalNotFound, isNotFound } from './not-found'\nimport { isRedirect } from './redirects'\nimport { type AnyRouter, type RegisteredRouter } from './router'\nimport type { ResolveRelativePath, ToOptions } from './link'\nimport type { AnyRoute, ReactNode, StaticDataRouteOption } from './route'\nimport type {\n  AllParams,\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport type {\n  ControlledPromise,\n  DeepPartial,\n  Expand,\n  NoInfer,\n  StrictOrFrom,\n} from './utils'\n\nexport const matchContext = React.createContext<string | undefined>(undefined)\n\nexport interface RouteMatch<\n  TRouteId,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TRouteContext,\n  TLoaderDeps,\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: TAllParams\n  status: 'pending' | 'success' | 'error' | 'redirected' | 'notFound'\n  isFetching: false | 'beforeLoad' | 'loader'\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise: ControlledPromise<void>\n  loaderPromise: Promise<TLoaderData>\n  loaderData?: TLoaderData\n  routeContext: TRouteContext\n  context: TAllContext\n  search: TFullSearchSchema\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: TLoaderDeps\n  preload: boolean\n  invalid: boolean\n  meta?: Array<JSX.IntrinsicElements['meta']>\n  links?: Array<JSX.IntrinsicElements['link']>\n  scripts?: Array<JSX.IntrinsicElements['script']>\n  headers?: Record<string, string>\n  globalNotFound?: boolean\n  staticData: StaticDataRouteOption\n  minPendingPromise?: ControlledPromise<void>\n}\n\nexport type MakeRouteMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TTypes extends AnyRoute['types'] = RouteById<TRouteTree, TRouteId>['types'],\n  TAllParams = TReturnIntersection extends false\n    ? TTypes['allParams']\n    : Partial<AllParams<TRouteTree>>,\n  TFullSearchSchema = TReturnIntersection extends false\n    ? TTypes['fullSearchSchema']\n    : Partial<FullSearchSchema<TRouteTree>>,\n  TLoaderData = TTypes['loaderData'],\n  TAllContext = TTypes['allContext'],\n  TRouteContext = TTypes['routeContext'],\n  TLoaderDeps = TTypes['loaderDeps'],\n> = RouteMatch<\n  TRouteId,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TRouteContext,\n  TLoaderDeps\n>\n\nexport type AnyRouteMatch = RouteMatch<any, any, any, any, any, any, any>\n\nexport function Matches() {\n  const matchId = useRouterState({\n    select: (s) => {\n      return s.matches[0]?.id\n    },\n  })\n\n  const resetKey = useRouterState({\n    select: (s) => s.resolvedLocation.state.key!,\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => resetKey}\n        errorComponent={ErrorComponent}\n        onCatch={(error) => {\n          warning(\n            false,\n            `The following error wasn't caught by any route! ðŸ‘‡ At the very least, consider setting an 'errorComponent' in your RootRoute!`,\n          )\n          console.error(error)\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matchId }: { matchId: string }) {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${matchId}\". Please file an issue!`,\n  )\n\n  const route: AnyRoute = router.routesById[routeId]\n\n  const PendingComponent =\n    route.options.pendingComponent ?? router.options.defaultPendingComponent\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ?? router.options.defaultErrorComponent\n\n  const routeNotFoundComponent = route.isRoot\n    ? // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n      route.options.notFoundComponent ??\n      router.options.notFoundRoute?.options.component\n    : route.options.notFoundComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ??\n    PendingComponent ??\n    route.options.component?.preload ??\n    route.options.pendingComponent?.preload ??\n    (route.options.errorComponent as any)?.preload\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  const ResolvedNotFoundBoundary = routeNotFoundComponent\n    ? CatchNotFound\n    : SafeFragment\n\n  const resetKey = useRouterState({\n    select: (s) => s.resolvedLocation.state.key!,\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <ResolvedSuspenseBoundary fallback={pendingElement}>\n        <ResolvedCatchBoundary\n          getResetKey={() => resetKey}\n          errorComponent={routeErrorComponent ?? ErrorComponent}\n          onCatch={(error) => {\n            // Forward not found errors (we don't want to show the error component for these)\n            if (isNotFound(error)) throw error\n            warning(false, `Error in route match: ${matchId}`)\n            console.error(error)\n          }}\n        >\n          <ResolvedNotFoundBoundary\n            fallback={(error) => {\n              // If the current not found handler doesn't exist or it has a\n              // route ID which doesn't match the current route, rethrow the error\n              if (\n                !routeNotFoundComponent ||\n                (error.routeId && error.routeId !== routeId) ||\n                (!error.routeId && !route.isRoot)\n              )\n                throw error\n\n              return React.createElement(routeNotFoundComponent, error as any)\n            }}\n          >\n            <MatchInner matchId={matchId} />\n          </ResolvedNotFoundBoundary>\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction MatchInner({\n  matchId,\n  // pendingElement,\n}: {\n  matchId: string\n  // pendingElement: any\n}): any {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const match = useRouterState({\n    select: (s) =>\n      pick(s.matches.find((d) => d.id === matchId)!, [\n        'id',\n        'status',\n        'error',\n        'loadPromise',\n        'minPendingPromise',\n      ]),\n  })\n\n  const RouteErrorComponent =\n    (route.options.errorComponent ?? router.options.defaultErrorComponent) ||\n    ErrorComponent\n\n  if (match.status === 'notFound') {\n    let error: unknown\n    if (isServerSideError(match.error)) {\n      const deserializeError =\n        router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n\n      error = deserializeError(match.error.data)\n    } else {\n      error = match.error\n    }\n\n    invariant(isNotFound(error), 'Expected a notFound error')\n\n    return renderRouteNotFound(router, route, error)\n  }\n\n  if (match.status === 'redirected') {\n    // Redirects should be handled by the router transition. If we happen to\n    // encounter a redirect here, it's a bug. Let's warn, but render nothing.\n    invariant(isRedirect(match.error), 'Expected a redirect error')\n\n    warning(\n      false,\n      'Tried to render a redirected route match! This is a weird circumstance, please file an issue!',\n    )\n\n    return null\n  }\n\n  if (match.status === 'error') {\n    // If we're on the server, we need to use React's new and super\n    // wonky api for throwing errors from a server side render inside\n    // of a suspense boundary. This is the only way to get\n    // renderToPipeableStream to not hang indefinitely.\n    // We'll serialize the error and rethrow it on the client.\n    if (router.isServer) {\n      return (\n        <RouteErrorComponent\n          error={match.error}\n          info={{\n            componentStack: '',\n          }}\n        />\n      )\n    }\n\n    if (isServerSideError(match.error)) {\n      const deserializeError =\n        router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n      throw deserializeError(match.error.data)\n    } else {\n      throw match.error\n    }\n  }\n\n  if (match.status === 'pending') {\n    // We're pending, and if we have a minPendingMs, we need to wait for it\n    const pendingMinMs =\n      route.options.pendingMinMs ?? router.options.defaultPendingMinMs\n\n    if (pendingMinMs && !match.minPendingPromise) {\n      // Create a promise that will resolve after the minPendingMs\n\n      match.minPendingPromise = createControlledPromise()\n\n      if (!router.isServer) {\n        Promise.resolve().then(() => {\n          router.__store.setState((s) => ({\n            ...s,\n            matches: s.matches.map((d) =>\n              d.id === match.id\n                ? { ...d, minPendingPromise: createControlledPromise() }\n                : d,\n            ),\n          }))\n        })\n\n        setTimeout(() => {\n          // We've handled the minPendingPromise, so we can delete it\n          router.__store.setState((s) => {\n            return {\n              ...s,\n              matches: s.matches.map((d) =>\n                d.id === match.id\n                  ? {\n                      ...d,\n                      minPendingPromise:\n                        (d.minPendingPromise?.resolve(), undefined),\n                    }\n                  : d,\n              ),\n            }\n          })\n        }, pendingMinMs)\n      }\n    }\n\n    throw match.loadPromise\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (match.status === 'success') {\n    const Comp = route.options.component ?? router.options.defaultComponent\n\n    if (Comp) {\n      return <Comp />\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport const Outlet = React.memo(function Outlet() {\n  const router = useRouter()\n  const matchId = React.useContext(matchContext)\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const { parentGlobalNotFound } = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const parentMatch = matches.find((d) => d.id === matchId)\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId}\"`,\n      )\n      return {\n        parentGlobalNotFound: parentMatch.globalNotFound,\n      }\n    },\n  })\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, undefined)\n  }\n\n  if (!childMatchId) {\n    return null\n  }\n\n  return <Match matchId={childMatchId} />\n})\n\nfunction renderRouteNotFound(router: AnyRouter, route: AnyRoute, data: any) {\n  if (!route.options.notFoundComponent) {\n    if (router.options.defaultNotFoundComponent) {\n      return <router.options.defaultNotFoundComponent data={data} />\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      warning(\n        route.options.notFoundComponent,\n        `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<div>Not Found<div>)`,\n      )\n    }\n\n    return <DefaultGlobalNotFound />\n  }\n\n  return <route.options.notFoundComponent data={data} />\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type UseMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n  TOptions extends ToOptions<\n    TRouter,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  > = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n  TRelaxedOptions = Omit<TOptions, 'search' | 'params'> &\n    DeepPartial<Pick<TOptions, 'search' | 'params'>>,\n> = TRelaxedOptions & MatchRouteOptions\n\nexport function useMatchRoute<TRouter extends AnyRouter = RegisteredRouter>() {\n  const router = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ):\n      | false\n      | RouteById<TRouter['routeTree'], TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch,\n      })\n    },\n    [router],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n> = UseMatchRouteOptions<\n  TRouter['routeTree'],\n  TFrom,\n  TTo,\n  TMaskFrom,\n  TMaskTo\n> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | ((\n        params?: RouteByPath<\n          TRouter['routeTree'],\n          ResolveRelativePath<TFrom, NoInfer<TTo>>\n        >['types']['allParams'],\n      ) => ReactNode)\n    | React.ReactNode\n}\n\nexport function MatchRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n>(\n  props: MakeMatchRouteOptions<\n    TRouter['routeTree'],\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  >,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return params ? props.children : null\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = MakeRouteMatch<TRouteTree, TFrom, TReturnIntersection>,\n  TSelected = TRouteMatch,\n>(\n  opts: StrictOrFrom<TFrom, TReturnIntersection> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  const nearestMatchId = React.useContext(matchContext)\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = state.matches.find((d) =>\n        opts.from ? opts.from === d.routeId : d.id === nearestMatchId,\n      )\n\n      invariant(\n        match,\n        `Could not find ${\n          opts.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'\n        }`,\n      )\n\n      return opts.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as TSelected\n}\n\nexport function useMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = Array<TRouteMatch>,\n>(opts?: {\n  select?: (matches: Array<TRouteMatch>) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  return useRouterState({\n    select: (state) => {\n      const matches = state.matches\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n\nexport function useParentMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = Array<TRouteMatch>,\n>(opts?: {\n  select?: (matches: Array<TRouteMatch>) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId),\n      )\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n\nexport function useChildMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TReturnIntersection extends boolean = false,\n  TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId, TReturnIntersection>,\n  T = Array<TRouteMatch>,\n>(opts?: {\n  select?: (matches: Array<TRouteMatch>) => T\n  experimental_returnIntersection?: TReturnIntersection\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1,\n      )\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n\nexport function useLoaderDeps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteMatch extends MakeRouteMatch<TRouteTree, TFrom> = MakeRouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderDeps'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s.loaderDeps)\n        : s.loaderDeps\n    },\n  })\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteMatch extends MakeRouteMatch<TRouteTree, TFrom> = MakeRouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderData'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s.loaderData as TRouteMatch)\n        : s.loaderData\n    },\n  }) as TSelected\n}\n\nexport function isServerSideError(error: unknown): error is {\n  __isServerError: true\n  data: Record<string, any>\n} {\n  if (!(typeof error === 'object' && error && 'data' in error)) return false\n  if (!('__isServerError' in error && error.__isServerError)) return false\n  if (!(typeof error.data === 'object' && error.data)) return false\n\n  return error.__isServerError === true\n}\n\nexport function defaultDeserializeError(serializedData: Record<string, any>) {\n  if ('name' in serializedData && 'message' in serializedData) {\n    const error = new Error(serializedData.message)\n    error.name = serializedData.name\n    if (process.env.NODE_ENV === 'development') {\n      error.stack = serializedData.stack\n    }\n    return error\n  }\n\n  return serializedData.data\n}\n", "import { last } from './utils'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  basepath: string\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n}\nexport function resolvePath({\n  basepath,\n  base,\n  to,\n  trailingSlash = 'never',\n}: ResolvePathOptions) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)?.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: 'pathname', value: '/' })\n    }\n  }\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Array<Segment> {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: any\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n}\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n}: InterpolatePathOptions) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params._splat\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        if (leaveParams) {\n          const value = params[segment.value]\n          return `${segment.value}${value ?? ''}`\n        }\n        return params![segment.value.substring(1)] ?? 'undefined'\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(basepath: string, pathname: string) {\n  return basepath != '/' ? pathname.replace(basepath, '') : pathname\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from)\n  // Default to to $ (wildcard)\n  const to = removeBasepath(basepath, `${matchLocation.to ?? '$'}`)\n\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  const isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            const _splat = decodeURI(\n              joinPaths(baseSegments.slice(i).map((d) => d.value)),\n            )\n            // TODO: Deprecate *\n            params['*'] = _splat\n            params['_splat'] = _splat\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = decodeURIComponent(\n              baseSegment.value,\n            )\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params['**'] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value))\n        return !!matchLocation.fuzzy && routeSegment?.value !== '/'\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? params : undefined\n}\n", "import { useMatch } from './Matches'\nimport type { AnyRoute } from './route'\nimport type { AllParams, RouteById, RouteIds } from './routeInfo'\nimport type { RegisteredRouter } from './router'\nimport type { Expand } from './utils'\nimport type { StrictOrFrom } from './utils'\n\nexport function useParams<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TReturnIntersection extends boolean = false,\n  TParams = TReturnIntersection extends false\n    ? RouteById<TRouteTree, TFrom>['types']['allParams']\n    : Expand<Partial<AllParams<TRouteTree>>>,\n  TSelected = TParams,\n>(\n  opts: StrictOrFrom<TFrom, TReturnIntersection> & {\n    select?: (params: TParams) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (match) => {\n      return opts.select ? opts.select(match.params as TParams) : match.params\n    },\n  }) as TSelected\n}\n", "import { useMatch } from './Matches'\nimport type { AnyRoute, RootSearchSchema } from './route'\nimport type { FullSearchSchema, RouteById, RouteIds } from './routeInfo'\nimport type { RegisteredRouter } from './router'\nimport type { MakeRouteMatch } from './Matches'\nimport type { StrictOrFrom } from './utils'\n\nexport function useSearch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TReturnIntersection extends boolean = false,\n  TSearch = TReturnIntersection extends false\n    ? Exclude<\n        RouteById<TRouteTree, TFrom>['types']['fullSearchSchema'],\n        RootSearchSchema\n      >\n    : Partial<Omit<FullSearchSchema<TRouteTree>, keyof RootSearchSchema>>,\n  TSelected = TSearch,\n>(\n  opts: StrictOrFrom<TFrom, TReturnIntersection> & {\n    select?: (search: TSearch) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...opts,\n    select: (match: MakeRouteMatch<TRouteTree, TFrom>) => {\n      return opts.select ? opts.select(match.search) : match.search\n    },\n  })\n}\n", "import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './useRouter'\n\nimport type { NavigateOptions } from './link'\nimport type { RoutePaths, RoutePathsAutoComplete } from './routeInfo'\nimport type { AnyRouter, RegisteredRouter } from './router'\n\nexport type UseNavigateResult<TDefaultFrom extends string> = <\n  TTo extends string,\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = TDefaultFrom,\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n>({\n  from,\n  ...rest\n}: NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>) => Promise<void>\n\nexport function useNavigate<\n  TDefaultFrom extends string = string,\n>(_defaultOpts?: {\n  from?: RoutePathsAutoComplete<RegisteredRouter['routeTree'], TDefaultFrom>\n}): UseNavigateResult<TDefaultFrom> {\n  const router = useRouter()\n\n  return React.useCallback(\n    (options: NavigateOptions) => {\n      return router.navigate({\n        ...options,\n        from: options.to ? router.state.resolvedLocation.pathname : undefined,\n      })\n    },\n    [router],\n  )\n}\n\n// NOTE: I don't know of anyone using this. It's undocumented, so let's wait until someone needs it\n// export function typedNavigate<\n//   TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n//   TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n// >(navigate: (opts: NavigateOptions<any>) => Promise<void>) {\n//   return navigate as <\n//     TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n//     TTo extends string = '',\n//     TMaskFrom extends RoutePaths<TRouteTree> = '/',\n//     TMaskTo extends string = '',\n//   >(\n//     opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n//   ) => Promise<void>\n// } //\n\nexport function Navigate<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n>(props: NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): null {\n  const { navigate } = useRouter()\n  const match = useMatch({ strict: false })\n\n  React.useEffect(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props,\n    } as any)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  return null\n}\n", "import invariant from 'tiny-invariant'\nimport { useLoaderData, useLoaderDeps, useMatch } from './Matches'\nimport { joinPaths, trimPathLeft } from './path'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport { notFound } from './not-found'\nimport { useNavigate } from './useNavigate'\nimport type { UseNavigateResult } from './useNavigate'\nimport type * as React from 'react'\nimport type { MakeRouteMatch, RouteMatch } from './Matches'\nimport type { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport type { ParsedLocation } from './location'\nimport type { RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport type { AnyRouter, RegisteredRouter, Router } from './router'\nimport type {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport type { BuildLocationFn, NavigateFn } from './RouterProvider'\nimport type { NotFoundError } from './not-found'\nimport type { LazyRoute } from './fileRoute'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type SearchSchemaInput = {\n  __TSearchSchemaInput__: 'TSearchSchemaInput'\n}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport interface StaticDataRouteOption {}\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TSearchSchemaUsed = {},\n  TFullSearchSchemaInput = TSearchSchemaUsed,\n  TFullSearchSchema = TSearchSchema,\n  TParams = AnyPathParams,\n  TAllParams = TParams,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchemaInput,\n  TSearchSchema,\n  TSearchSchemaUsed,\n  TFullSearchSchemaInput,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContextReturn,\n  TRouteContext,\n  TRouterContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderDataReturn\n> &\n  UpdatableRouteOptions<\n    NoInfer<TCustomId>,\n    NoInfer<TAllParams>,\n    NoInfer<TFullSearchSchema>,\n    NoInfer<TLoaderData>,\n    NoInfer<TAllContext>,\n    NoInfer<TRouteContext>,\n    NoInfer<TLoaderDeps>\n  >\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\nexport type FileBaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema = TSearchSchema,\n  TParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n> = {\n  validateSearch?: SearchSchemaValidator<TSearchSchemaInput, TSearchSchema>\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TAllParams,\n          TFullSearchSchema,\n          TAllContext,\n          TRouteContext\n        >,\n      ) => any)\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: BeforeLoadFn<\n    TFullSearchSchema,\n    TParentRoute,\n    TAllParams,\n    TRouteContextReturn,\n    TRouterContext\n  >\n  loaderDeps?: (opts: { search: TFullSearchSchema }) => TLoaderDeps\n  loader?: RouteLoaderFn<\n    TAllParams,\n    NoInfer<TLoaderDeps>,\n    NoInfer<TAllContext>,\n    NoInfer<TRouteContext>,\n    TLoaderDataReturn\n  >\n} & (\n  | {\n      // Both or none\n      parseParams?: (\n        rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n      ) => TParams extends Record<ParsePathParams<TPath>, any>\n        ? TParams\n        : 'parseParams must return an object'\n      stringifyParams?: (\n        params: NoInfer<ParamsFallback<TPath, TParams>>,\n      ) => Record<ParsePathParams<TPath>, string>\n    }\n  | {\n      stringifyParams?: never\n      parseParams?: never\n    }\n)\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends Record<string, any> = {},\n  TSearchSchemaUsed = {},\n  TFullSearchSchemaInput = TSearchSchemaUsed,\n  TFullSearchSchema = TSearchSchema,\n  TParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext = RouteContext,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TAllContext = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n> = RoutePathOptions<TCustomId, TPath> &\n  FileBaseRouteOptions<\n    TParentRoute,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn\n  > & {\n    getParentRoute: () => TParentRoute\n  }\n\ntype BeforeLoadFn<\n  in out TFullSearchSchema,\n  in out TParentRoute extends AnyRoute,\n  in out TAllParams,\n  TRouteContextReturn extends RouteContext,\n  in out TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  in out TContext = IsAny<TParentRoute['types']['allContext'], TRouterContext>,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TContext\n  location: ParsedLocation\n  navigate: NavigateFn\n  buildLocation: BuildLocationFn<TParentRoute>\n  cause: 'preload' | 'enter' | 'stay'\n}) => Promise<TRouteContextReturn> | TRouteContextReturn | void\n\nexport type UpdatableRouteOptions<\n  TRouteId,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TRouteContext,\n  TLoaderDeps,\n  TRouteMatch = RouteMatch<\n    TRouteId,\n    TAllParams,\n    TFullSearchSchema,\n    TLoaderData,\n    TAllContext,\n    TRouteContext,\n    TLoaderDeps\n  >,\n> = {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  notFoundComponent?: NotFoundRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: Array<SearchFilter<TFullSearchSchema>>\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: Array<SearchFilter<TFullSearchSchema>>\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: TRouteMatch) => void\n  onStay?: (match: TRouteMatch) => void\n  onLeave?: (match: TRouteMatch) => void\n  meta?: (ctx: {\n    params: TAllParams\n    loaderData: TLoaderData\n  }) => Array<JSX.IntrinsicElements['meta']>\n  links?: () => Array<JSX.IntrinsicElements['link']>\n  scripts?: () => Array<JSX.IntrinsicElements['script']>\n  headers?: (ctx: { loaderData: TLoaderData }) => Record<string, string>\n} & UpdatableStaticRouteOption\n\nexport type UpdatableStaticRouteOption =\n  {} extends PickRequired<StaticDataRouteOption>\n    ? {\n        staticData?: StaticDataRouteOption\n      }\n    : {\n        staticData: StaticDataRouteOption\n      }\n\nexport type MetaDescriptor =\n  | { charSet: 'utf-8' }\n  | { title: string }\n  | { name: string; content: string }\n  | { property: string; content: string }\n  | { httpEquiv: string; content: string }\n  | { 'script:ld+json': LdJsonObject }\n  | { tagName: 'meta' | 'link'; [name: string]: string }\n  | Record<string, unknown>\n\ntype LdJsonObject = { [Key in string]: LdJsonValue } & {\n  [Key in string]?: LdJsonValue | undefined\n}\ntype LdJsonArray = Array<LdJsonValue> | ReadonlyArray<LdJsonValue>\ntype LdJsonPrimitive = string | number | boolean | null\ntype LdJsonValue = LdJsonPrimitive | LdJsonObject | LdJsonArray\n\nexport type RouteLinkEntry = {}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TInput, TReturn> =\n  | SearchSchemaValidatorObj<TInput, TReturn>\n  | SearchSchemaValidatorFn<TInput, TReturn>\n\nexport type SearchSchemaValidatorObj<TInput, TReturn> = {\n  parse?: SearchSchemaValidatorFn<TInput, TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TInput, TReturn> = (\n  searchObj: TInput,\n) => TReturn\n\nexport type RouteLoaderFn<\n  in out TAllParams = {},\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TAllContext = AnyContext,\n  in out TRouteContext = AnyContext,\n  TLoaderData = unknown,\n> = (\n  match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>,\n) => Promise<TLoaderData> | TLoaderData\n\nexport interface LoaderFnContext<\n  in out TAllParams = {},\n  in out TLoaderDeps = {},\n  in out TAllContext = AnyContext,\n  in out TRouteContext = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  deps: TLoaderDeps\n  context: Assign<TAllContext, TRouteContext>\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  /**\n   * @deprecated Use `throw redirect({ to: '/somewhere' })` instead\n   **/\n  navigate: (opts: NavigateOptions<AnyRouter>) => Promise<void>\n  parentMatchPromise?: Promise<void>\n  cause: 'preload' | 'enter' | 'stay'\n  route: Route\n}\n\nexport type SearchFilter<TInput, TResult = TInput> = (prev: TInput) => TResult\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type InferFullSearchSchemaInput<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchemaInput: infer TFullSearchSchemaInput\n  }\n}\n  ? TFullSearchSchemaInput\n  : {}\n\nexport type ResolveFullSearchSchema<\n  TParentRoute extends AnyRoute,\n  TSearchSchema,\n> = Assign<\n  TParentRoute['id'] extends RootRouteId\n    ? Omit<TParentRoute['types']['searchSchema'], keyof RootSearchSchema>\n    : TParentRoute['types']['fullSearchSchema'],\n  TSearchSchema\n>\n\nexport type ResolveFullSearchSchemaInput<\n  TParentRoute extends AnyRoute,\n  TSearchSchemaUsed,\n> = Assign<\n  TParentRoute['id'] extends RootRouteId\n    ? Omit<TParentRoute['types']['searchSchemaInput'], keyof RootSearchSchema>\n    : TParentRoute['types']['fullSearchSchemaInput'],\n  TSearchSchemaUsed\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type ResolveAllParams<TParentRoute extends AnyRoute, TParams> =\n  Record<never, string> extends TParentRoute['types']['allParams']\n    ? TParams\n    : UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport function getRouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema = TRoute['types']['fullSearchSchema'],\n  TAllParams = TRoute['types']['allParams'],\n  TAllContext = TRoute['types']['allContext'],\n  TLoaderDeps = TRoute['types']['loaderDeps'],\n  TLoaderData = TRoute['types']['loaderData'],\n>(id: TId) {\n  return new RouteApi<\n    TId,\n    TRoute,\n    TFullSearchSchema,\n    TAllParams,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderData\n  >({ id })\n}\n\nexport class RouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema = TRoute['types']['fullSearchSchema'],\n  TAllParams = TRoute['types']['allParams'],\n  TAllContext = TRoute['types']['allContext'],\n  TLoaderDeps = TRoute['types']['loaderDeps'],\n  TLoaderData = TRoute['types']['loaderData'],\n> {\n  id: TId\n\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch = <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TRouteMatch = MakeRouteMatch<TRouteTree, TId>,\n    TSelected = TRouteMatch,\n  >(opts?: {\n    select?: (match: TRouteMatch) => TSelected\n  }): TSelected => {\n    return useMatch({ select: opts?.select, from: this.id })\n  }\n\n  useRouteContext = <TSelected = Expand<TAllContext>>(opts?: {\n    select?: (s: Expand<TAllContext>) => TSelected\n  }): TSelected => {\n    return useMatch({\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = Expand<TFullSearchSchema>>(opts?: {\n    select?: (s: Expand<TFullSearchSchema>) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TSelected = Expand<TAllParams>>(opts?: {\n    select?: (s: Expand<TAllParams>) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id })\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (s: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useNavigate = () => {\n    return useNavigate({ from: this.id })\n  }\n\n  notFound = (opts?: NotFoundError) => {\n    return notFound({ routeId: this.id as string, ...opts })\n  }\n}\n\nexport class Route<\n  in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  in out TPath extends RouteConstraints['TPath'] = '/',\n  in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  in out TCustomId extends RouteConstraints['TCustomId'] = string,\n  in out TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  in out TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {},\n  in out TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  in out TSearchSchemaUsed = TSearchSchemaInput extends SearchSchemaInput\n    ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n    : TSearchSchema,\n  in out TFullSearchSchemaInput = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  in out TFullSearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  in out TParams = Record<ParsePathParams<TPath>, string>,\n  in out TAllParams = ResolveAllParams<TParentRoute, TParams>,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = RouteContext,\n  in out TRouteContext = [TRouteContextReturn] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  in out TAllContext = Assign<\n    IsAny<TParentRoute['types']['allContext'], {}>,\n    TRouteContext\n  >,\n  in out TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  in out TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  in out TChildren extends RouteConstraints['TChildren'] = unknown,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n  lazyFn?: () => Promise<LazyRoute<any>>\n\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(\n    options?: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TFullSearchSchemaInput,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    searchSchemaInput: TSearchSchemaInput\n    searchSchemaUsed: TSearchSchemaUsed\n    fullSearchSchema: TFullSearchSchema\n    fullSearchSchemaInput: TFullSearchSchemaInput\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routerContext: TRouterContext\n    loaderData: TLoaderData\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number }): void => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as\n      | (RouteOptions<\n          TParentRoute,\n          TCustomId,\n          TPath,\n          TSearchSchemaInput,\n          TSearchSchema,\n          TSearchSchemaUsed,\n          TFullSearchSchemaInput,\n          TFullSearchSchema,\n          TParams,\n          TAllParams,\n          TRouteContextReturn,\n          TRouteContext,\n          TRouterContext,\n          TAllContext,\n          TLoaderDeps,\n          TLoaderDataReturn,\n          TLoaderData\n        > &\n          RoutePathOptionsIntersection<TCustomId, TPath>)\n      | undefined\n\n    const isRoot = !options?.path && !options?.id\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPathLeft(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <const TNewChildren extends ReadonlyArray<AnyRoute>>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TNewChildren\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  updateLoader = <TNewLoaderData = unknown>(options: {\n    loader: RouteLoaderFn<\n      TAllParams,\n      TLoaderDeps,\n      TAllContext,\n      TRouteContext,\n      TNewLoaderData\n    >\n  }) => {\n    Object.assign(this.options, options)\n    return this as unknown as Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TFullSearchSchemaInput,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TAllContext,\n      TRouterContext,\n      TLoaderDeps,\n      TNewLoaderData,\n      TChildren\n    >\n  }\n\n  update = (\n    options: UpdatableRouteOptions<\n      TCustomId,\n      TAllParams,\n      TFullSearchSchema,\n      TLoaderData,\n      TAllContext,\n      TRouteContext,\n      TLoaderDeps\n    >,\n  ): this => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  lazy = (lazyFn: () => Promise<LazyRoute<any>>): this => {\n    this.lazyFn = lazyFn\n    return this\n  }\n\n  useMatch = <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TRouteMatch = MakeRouteMatch<TRouteTree, TId>,\n    TSelected = TRouteMatch,\n  >(opts?: {\n    select?: (match: TRouteMatch) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id })\n  }\n\n  useRouteContext = <TSelected = Expand<TAllContext>>(opts?: {\n    select?: (search: Expand<TAllContext>) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = Expand<TFullSearchSchema>>(opts?: {\n    select?: (search: Expand<TFullSearchSchema>) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TSelected = Expand<TAllParams>>(opts?: {\n    select?: (search: Expand<TAllParams>) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id })\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<string> => {\n    return useNavigate({ from: this.id })\n  }\n}\n\nexport function createRoute<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchemaUsed = TSearchSchemaInput extends SearchSchemaInput\n    ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n    : TSearchSchema,\n  TFullSearchSchemaInput = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>,\n  TParams = Record<ParsePathParams<TPath>, string>,\n  TAllParams = ResolveAllParams<TParentRoute, TParams>,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = RouteContext,\n  TRouteContext = [TRouteContextReturn] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  TAllContext = Assign<\n    IsAny<TParentRoute['types']['allContext'], {}>,\n    TRouteContext\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n>(\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >,\n) {\n  return new Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TChildren\n  >(options)\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any>\n\nexport function createRootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n    TSearchSchema extends Record<string, any> = RootSearchSchema,\n    TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n    TRouteContextReturn extends RouteContext = RouteContext,\n    TRouteContext extends RouteContext = [TRouteContextReturn] extends [never]\n      ? RouteContext\n      : TRouteContextReturn,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderDataReturn = unknown,\n    TLoaderData = [TLoaderDataReturn] extends [never]\n      ? undefined\n      : TLoaderDataReturn,\n  >(\n    options?: Omit<\n      RouteOptions<\n        any, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchemaInput, // TSearchSchemaInput\n        TSearchSchema, // TSearchSchema\n        TSearchSchemaUsed,\n        TSearchSchemaUsed, //TFullSearchSchemaInput\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContextReturn, // TRouteContextReturn\n        TRouteContext, // TRouteContext\n        TRouterContext,\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderDataReturn, // TLoaderDataReturn,\n        TLoaderData // TLoaderData,\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) => {\n    return createRootRoute<\n      TSearchSchemaInput,\n      TSearchSchema,\n      TSearchSchemaUsed,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TLoaderDeps,\n      TLoaderData\n    >(options as any)\n  }\n}\n\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\nexport const rootRouteWithContext = createRootRouteWithContext\n\nexport type RootSearchSchema = {\n  __TRootSearchSchema__: '__TRootSearchSchema__'\n}\n\nexport class RootRoute<\n  in out TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n  in out TSearchSchema extends Record<string, any> = RootSearchSchema,\n  in out TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  in out TRouteContext extends RouteContext = [TRouteContextReturn] extends [\n    never,\n  ]\n    ? RouteContext\n    : TRouteContextReturn,\n  in out TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  in out TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchemaInput, // TSearchSchemaInput\n  TSearchSchema, // TSearchSchema\n  TSearchSchemaUsed,\n  TSearchSchemaUsed, // TFullSearchSchemaInput\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContextReturn, // TRouteContextReturn\n  TRouteContext, // TRouteContext\n  Assign<TRouterContext, TRouteContext>, // TAllContext\n  TRouterContext, // TRouterContext\n  TLoaderDeps,\n  TLoaderDataReturn,\n  TLoaderData,\n  any // TChildren\n> {\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        any, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchemaInput, // TSearchSchemaInput\n        TSearchSchema, // TSearchSchema\n        TSearchSchemaUsed,\n        TSearchSchemaUsed, // TFullSearchSchemaInput\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContextReturn, // TRouteContextReturn\n        TRouteContext, // TRouteContext\n        TRouterContext,\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderDataReturn,\n        TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport function createRootRoute<\n  TSearchSchemaInput extends Record<string, any> = RootSearchSchema,\n  TSearchSchema extends Record<string, any> = RootSearchSchema,\n  TSearchSchemaUsed extends Record<string, any> = RootSearchSchema,\n  TRouteContextReturn extends RouteContext = RouteContext,\n  TRouteContext extends RouteContext = [TRouteContextReturn] extends [never]\n    ? RouteContext\n    : TRouteContextReturn,\n  TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n>(\n  options?: Omit<\n    RouteOptions<\n      any, // TParentRoute\n      RootRouteId, // TCustomId\n      '', // TPath\n      TSearchSchemaInput, // TSearchSchemaInput\n      TSearchSchema, // TSearchSchema\n      TSearchSchemaUsed,\n      TSearchSchemaUsed, // TFullSearchSchemaInput\n      TSearchSchema, // TFullSearchSchema\n      {}, // TParams\n      {}, // TAllParams\n      TRouteContextReturn, // TRouteContextReturn\n      TRouteContext, // TRouteContext\n      TRouterContext,\n      Assign<TRouterContext, TRouteContext>, // TAllContext\n      TLoaderDeps,\n      TLoaderDataReturn,\n      TLoaderData\n    >,\n    | 'path'\n    | 'id'\n    | 'getParentRoute'\n    | 'caseSensitive'\n    | 'parseParams'\n    | 'stringifyParams'\n  >,\n) {\n  return new RootRoute<\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TRouteContextReturn,\n    TRouteContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData\n  >(options)\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<Router<TRouteTree, 'never'>, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\n/**\n * @deprecated Use `ErrorComponentProps` instead.\n */\nexport type ErrorRouteProps = {\n  error: unknown\n  info?: { componentStack: string }\n  reset: () => void\n}\n\nexport type ErrorComponentProps = {\n  error: unknown\n  info?: { componentStack: string }\n  reset: () => void\n}\nexport type NotFoundRouteProps = {\n  // TODO: Make sure this is `| null | undefined` (this is for global not-founds)\n  data: unknown\n}\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = SyncRouteComponent<TProps> &\n  AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorComponentProps>\n\nexport type NotFoundRouteComponent = SyncRouteComponent<NotFoundRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TSearchSchemaInput extends Record<string, any> = {},\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TSearchSchemaUsed extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchemaInput extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchSchemaUsed\n  >,\n  TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>,\n  TRouteContextReturn extends RouteConstraints['TRouteContext'] = AnyContext,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext = Assign<\n    IsAny<TParentRoute['types']['allContext'], {}>,\n    TRouteContext\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderDataReturn = unknown,\n  TLoaderData = [TLoaderDataReturn] extends [never]\n    ? undefined\n    : TLoaderDataReturn,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchSchemaInput,\n  TSearchSchema,\n  TSearchSchemaUsed,\n  TFullSearchSchemaInput,\n  TFullSearchSchema,\n  {},\n  {},\n  TRouteContextReturn,\n  TRouteContext,\n  TAllContext,\n  TRouterContext,\n  TLoaderDeps,\n  TLoaderDataReturn,\n  TLoaderData,\n  TChildren\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchemaInput,\n        TSearchSchema,\n        TSearchSchemaUsed,\n        TFullSearchSchemaInput,\n        TFullSearchSchema,\n        {},\n        {},\n        TRouteContextReturn,\n        TRouteContext,\n        TRouterContext,\n        TAllContext,\n        TLoaderDeps,\n        TLoaderDataReturn,\n        TLoaderData\n      >,\n      'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n", "// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\n/**\n * Encodes an object into a query string.\n * @param obj - The object to encode into a query string.\n * @param [pfx] - An optional prefix to add before the query string.\n * @returns The encoded query string.\n * @example\n * ```\n * // Example input: encode({ token: 'foo', key: 'value' })\n * // Expected output: \"token=foo&key=value\"\n * ```\n */\nexport function encode(obj, pfx?: string) {\n  let k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\n/**\n * Converts a string value to its appropriate type (string, number, boolean).\n * @param mix - The string value to convert.\n * @returns The converted value.\n * @example\n * // Example input: toValue(\"123\")\n * // Expected output: 123\n */\nfunction toValue(mix) {\n  if (!mix) return ''\n  const str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\n/**\n * Decodes a query string into an object.\n * @param str - The query string to decode.\n * @param [pfx] - An optional prefix to filter out from the query string.\n * @returns The decoded key-value pairs in an object format.\n * @example\n * // Example input: decode(\"token=foo&key=value\")\n * // Expected output: { \"token\": \"foo\", \"key\": \"value\" }\n */\nexport function decode(str, pfx?: string) {\n  let tmp, k\n  const out = {},\n    arr = (pfx ? str.substr(pfx.length) : str).split('&')\n\n  while ((tmp = arr.shift())) {\n    const equalIndex = tmp.indexOf('=')\n    if (equalIndex !== -1) {\n      k = tmp.slice(0, equalIndex)\n      const value = tmp.slice(equalIndex + 1)\n      if (out[k] !== void 0) {\n        out[k] = [].concat(out[k], toValue(value))\n      } else {\n        out[k] = toValue(value)\n      }\n    } else {\n      k = tmp\n      out[k] = ''\n    }\n  }\n\n  return out\n}\n", "import { decode, encode } from './qss'\nimport type { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    const query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (const key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    Object.keys(search).forEach((key) => {\n      const val = search[key]\n      if (typeof val === 'undefined' || val === undefined) {\n        delete search[key]\n      } else {\n        search[key] = stringifyValue(val)\n      }\n    })\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n", "import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport { Matches } from './Matches'\nimport { pick, useLayoutEffect } from './utils'\nimport { useRouter } from './useRouter'\nimport { useRouterState } from './useRouterState'\nimport { getRouterContext } from './routerContext'\nimport type { NavigateOptions, ToOptions } from './link'\nimport type { ParsedLocation } from './location'\nimport type { AnyRoute } from './route'\nimport type { RoutePaths } from './routeInfo'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  Router,\n  RouterOptions,\n  RouterState,\n} from './router'\n\nimport type { MakeRouteMatch } from './Matches'\n\nexport interface CommitLocationOptions {\n  replace?: boolean\n  resetScroll?: boolean\n  viewTransition?: boolean\n  /**\n   * @deprecated All navigations use React transitions under the hood now\n   **/\n  startTransition?: boolean\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n}\n\nexport type NavigateFn = <\n  TTo extends string,\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => Promise<void>\n\nexport type BuildLocationFn<TRouteTree extends AnyRoute> = <\n  TTo extends string,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: ToOptions<\n    Router<TRouteTree, 'never'>,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  > & {\n    leaveParams?: boolean\n  },\n) => ParsedLocation\n\nexport type InjectedHtmlEntry = string | (() => Promise<string> | string)\n\nexport function RouterProvider<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouter, TDehydrated>) {\n  // Allow the router to update options on the router instance\n  router.update({\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest.context,\n    },\n  } as any)\n\n  const matches = router.options.InnerWrap ? (\n    <router.options.InnerWrap>\n      <Matches />\n    </router.options.InnerWrap>\n  ) : (\n    <Matches />\n  )\n\n  const routerContext = getRouterContext()\n\n  const provider = (\n    <React.Suspense fallback={null}>\n      <routerContext.Provider value={router}>\n        {matches}\n        <Transitioner />\n      </routerContext.Provider>\n    </React.Suspense>\n  )\n\n  if (router.options.Wrap) {\n    return <router.options.Wrap>{provider}</router.options.Wrap>\n  }\n\n  return provider\n}\n\nfunction Transitioner() {\n  const router = useRouter()\n  const mountLoadForRouter = React.useRef({ router, mounted: false })\n  const routerState = useRouterState({\n    select: (s) =>\n      pick(s, ['isLoading', 'location', 'resolvedLocation', 'isTransitioning']),\n  })\n\n  const [isTransitioning, startReactTransition_] = React.useTransition()\n  // Track pending state changes\n  const hasPendingMatches = useRouterState({\n    select: (s) => s.matches.some((d) => d.status === 'pending'),\n  })\n\n  const previousIsLoading = usePrevious(routerState.isLoading)\n\n  const isAnyPending =\n    routerState.isLoading || isTransitioning || hasPendingMatches\n  const previousIsAnyPending = usePrevious(isAnyPending)\n\n  router.startReactTransition = startReactTransition_\n\n  const tryLoad = () => {\n    try {\n      router.load()\n    } catch (err) {\n      console.error(err)\n    }\n  }\n\n  // Subscribe to location changes\n  // and try to load the new location\n  useLayoutEffect(() => {\n    const unsub = router.history.subscribe(() => {\n      router.latestLocation = router.parseLocation(router.latestLocation)\n      if (router.state.location !== router.latestLocation) {\n        tryLoad()\n      }\n    })\n\n    const nextLocation = router.buildLocation({\n      to: router.latestLocation.pathname,\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (routerState.location.href !== nextLocation.href) {\n      router.commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [router, router.history])\n\n  // Try to load the initial location\n  useLayoutEffect(() => {\n    if (\n      window.__TSR_DEHYDRATED__ ||\n      (mountLoadForRouter.current.router === router &&\n        mountLoadForRouter.current.mounted)\n    ) {\n      return\n    }\n    mountLoadForRouter.current = { router, mounted: true }\n    tryLoad()\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [router])\n\n  useLayoutEffect(() => {\n    // The router was loading and now it's not\n    if (previousIsLoading && !routerState.isLoading) {\n      const toLocation = router.state.location\n      const fromLocation = router.state.resolvedLocation\n      const pathChanged = fromLocation.href !== toLocation.href\n\n      router.emit({\n        type: 'onLoad',\n        fromLocation,\n        toLocation,\n        pathChanged,\n      })\n\n      // if (router.viewTransitionPromise) {\n      //   console.log('resolving view transition promise')\n      // }\n\n      // router.viewTransitionPromise?.resolve(true)\n    }\n  }, [previousIsLoading, router, routerState.isLoading])\n\n  useLayoutEffect(() => {\n    // The router was pending and now it's not\n    if (previousIsAnyPending && !isAnyPending) {\n      const toLocation = router.state.location\n      const fromLocation = router.state.resolvedLocation\n      const pathChanged = fromLocation.href !== toLocation.href\n\n      router.emit({\n        type: 'onResolved',\n        fromLocation,\n        toLocation,\n        pathChanged,\n      })\n\n      router.__store.setState((s) => ({\n        ...s,\n        status: 'idle',\n        resolvedLocation: s.location,\n      }))\n\n      if ((document as any).querySelector) {\n        if (router.state.location.hash !== '') {\n          const el = document.getElementById(router.state.location.hash)\n          if (el) {\n            el.scrollIntoView()\n          }\n        }\n      }\n    }\n  }, [isAnyPending, previousIsAnyPending, router])\n\n  return null\n}\n\nexport function getRouteMatch<TRouteTree extends AnyRoute>(\n  state: RouterState<TRouteTree>,\n  id: string,\n): undefined | MakeRouteMatch<TRouteTree> {\n  return [\n    ...state.cachedMatches,\n    ...(state.pendingMatches ?? []),\n    ...state.matches,\n  ].find((d) => d.id === id)\n}\n\nexport type RouterProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouter['routeTree'],\n    NonNullable<TRouter['options']['trailingSlash']>,\n    TDehydrated\n  >,\n  'context'\n> & {\n  router: Router<\n    TRouter['routeTree'],\n    NonNullable<TRouter['options']['trailingSlash']>\n  >\n  context?: Partial<\n    RouterOptions<\n      TRouter['routeTree'],\n      NonNullable<TRouter['options']['trailingSlash']>,\n      TDehydrated\n    >['context']\n  >\n}\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef<T>(value)\n  React.useEffect(() => {\n    ref.current = value\n  })\n  return ref.current\n}\n", "import { createBrowserHistory, createMemoryHistory } from '@tanstack/history'\nimport { Store } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { rootRouteId } from './route'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  createControlledPromise,\n  deepEqual,\n  escapeJSON,\n  functionalUpdate,\n  last,\n  pick,\n  replaceEqualDeep,\n} from './utils'\nimport { getRouteMatch } from './RouterProvider'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport { isRedirect } from './redirects'\nimport { isNotFound } from './not-found'\nimport type * as React from 'react'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n} from '@tanstack/history'\n\n//\n\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnySearchSchema,\n  ErrorRouteComponent,\n  LoaderFnContext,\n  NotFoundRouteComponent,\n  RouteMask,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  ControlledPromise,\n  NonNullableUpdater,\n  PickAsRequired,\n  Timeout,\n  Updater,\n} from './utils'\nimport type { RouteComponent } from './route'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MatchRouteOptions,\n  RouteMatch,\n} from './Matches'\nimport type { ParsedLocation } from './location'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  InjectedHtmlEntry,\n  NavigateFn,\n} from './RouterProvider'\n\nimport type { AnyRedirect, ResolvedRedirect } from './redirects'\n\nimport type { NotFoundError } from './not-found'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { NoInfer } from '@tanstack/react-store'\nimport type { DeferredPromiseState } from './defer'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: { data: string }\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any, any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any, any, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport type TrailingSlashOption = 'always' | 'never' | 'preserve'\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: ErrorRouteComponent\n  defaultPendingComponent?: RouteComponent\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultStaleTime?: number\n  defaultPreloadStaleTime?: number\n  defaultPreloadGcTime?: number\n  defaultViewTransition?: boolean\n  notFoundMode?: 'root' | 'fuzzy'\n  defaultGcTime?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  context?: TRouteTree['types']['routerContext']\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  unmaskOnReload?: boolean\n  Wrap?: (props: { children: any }) => React.JSX.Element\n  InnerWrap?: (props: { children: any }) => React.JSX.Element\n  /**\n   * @deprecated\n   * Use `notFoundComponent` instead.\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   */\n  notFoundRoute?: AnyRoute\n  defaultNotFoundComponent?: NotFoundRouteComponent\n  transformer?: RouterTransformer\n  errorSerializer?: RouterErrorSerializer<TSerializedError>\n  trailingSlash?: TTrailingSlashOption\n}\n\nexport interface RouterTransformer {\n  stringify: (obj: unknown) => string\n  parse: (str: string) => unknown\n}\nexport interface RouterErrorSerializer<TSerializedError> {\n  serialize: (err: unknown) => TSerializedError\n  deserialize: (err: TSerializedError) => unknown\n}\n\nexport interface RouterState<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteMatch = MakeRouteMatch<TRouteTree>,\n> {\n  status: 'pending' | 'idle'\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: ResolvedRedirect\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  fromSearch?: unknown\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: Array<DehydratedRouteMatch>\n}\n\nexport type DehydratedRouteMatch = Pick<\n  MakeRouteMatch,\n  'id' | 'status' | 'updatedAt' | 'loaderData'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any>,\n  TSerializedError extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >,\n  'context'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n  'notFoundComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport function createRouter<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n>(\n  options: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >,\n) {\n  return new Router<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >(options)\n}\n\nexport class Router<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n  in out TSerializedError extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: true = undefined\n  latestLoadPromise: Promise<void> = Promise.resolve()\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  injectedHtml: Array<InjectedHtmlEntry> = []\n  dehydratedData?: TDehydrated\n  viewTransitionPromise?: ControlledPromise<true>\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    Omit<\n      RouterOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDehydrated,\n        TSerializedError\n      >,\n      'transformer'\n    > & {\n      transformer: RouterTransformer\n    },\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: Array<AnyRoute>\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDehydrated,\n      TSerializedError\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n      transformer: options.transformer ?? JSON,\n    })\n\n    if (typeof document !== 'undefined') {\n      ;(window as any).__TSR__ROUTER__ = this\n    }\n  }\n\n  isServer = typeof document === 'undefined'\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n\n  update = (\n    newOptions: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDehydrated,\n      TSerializedError\n    >,\n  ) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const previousOptions = this.options\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    if (\n      !this.basepath ||\n      (newOptions.basepath && newOptions.basepath !== previousOptions.basepath)\n    ) {\n      if (\n        newOptions.basepath === undefined ||\n        newOptions.basepath === '' ||\n        newOptions.basepath === '/'\n      ) {\n        this.basepath = '/'\n      } else {\n        this.basepath = `/${trimPath(newOptions.basepath)}`\n      }\n    }\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (typeof document !== 'undefined'\n          ? createBrowserHistory()\n          : createMemoryHistory({\n              initialEntries: [this.options.basepath || '/'],\n            }))\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({ originalIndex: 99999999999 })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: Array<AnyRoute>) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: Array<{\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: Array<number>\n    }> = []\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    const routes = Object.values(this.routesById) as Array<AnyRoute>\n\n    routes.forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((segment) => {\n        if (segment.value === '/') {\n          return 0.75\n        }\n\n        if (segment.type === 'param') {\n          return 0.5\n        }\n\n        if (segment.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value > b.parsed[i]!.value ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return this.latestLoadPromise !== promise\n      ? this.latestLoadPromise\n      : undefined\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n\n      return {\n        pathname: pathname,\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${searchStr}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      basepath: this.basepath,\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes = (\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { preload?: boolean; throwOnError?: boolean },\n  ): Array<AnyRouteMatch> => {\n    let routeParams: Record<string, string> = {}\n\n    const foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)[rootRouteId]\n\n    const matchedRoutes: Array<AnyRoute> = [routeCursor]\n\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    while (routeCursor.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      matchedRoutes.unshift(routeCursor)\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: Array<AnyRouteMatch> = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          const search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchParamError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const interpolatedPath = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n      })\n\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n        }) + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = getRouteMatch(this.state, matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: routeParams,\n        }\n      } else {\n        const status =\n          route.options.loader || route.options.beforeLoad\n            ? 'pending'\n            : 'success'\n\n        const loadPromise = createControlledPromise<void>()\n\n        // If it's already a success, resolve the load promise\n        if (status === 'success') {\n          loadPromise.resolve()\n        }\n\n        match = {\n          id: matchId,\n          routeId: route.id,\n          params: routeParams,\n          pathname: joinPaths([this.basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          search: {} as any,\n          searchError: undefined,\n          status: 'pending',\n          isFetching: false,\n          error: undefined,\n          paramsError: parseErrors[index],\n          loaderPromise: Promise.resolve(),\n          loadPromise,\n          routeContext: undefined!,\n          context: undefined!,\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps,\n          invalid: false,\n          preload: false,\n          links: route.options.links?.(),\n          scripts: route.options.scripts?.(),\n          staticData: route.options.staticData || {},\n        }\n      }\n\n      // If it's already a success, update the meta and headers\n      // These may get updated again if the match is refreshed\n      // due to being stale\n      if (match.status === 'success') {\n        match.meta = route.options.meta?.({\n          params: match.params,\n          loaderData: match.loaderData,\n        })\n\n        match.headers = route.options.headers?.({\n          loaderData: match.loaderData,\n        })\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    getRouteMatch(this.state, id)?.abortController.abort()\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn<TRouteTree> = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: Array<MakeRouteMatch<TRouteTree>>,\n    ): ParsedLocation => {\n      let fromPath = this.latestLocation.pathname\n      let fromSearch = dest.fromSearch || this.latestLocation.search\n\n      const fromMatches = this.matchRoutes(\n        this.latestLocation.pathname,\n        fromSearch,\n      )\n\n      fromPath =\n        fromMatches.find((d) => d.id === dest.from)?.pathname || fromPath\n      fromSearch = last(fromMatches)?.search || this.latestLocation.search\n\n      const stayingMatches = matches?.filter((d) =>\n        fromMatches.find((e) => e.routeId === d.routeId),\n      )\n\n      let pathname = dest.to\n        ? this.resolvePathWithBase(fromPath, `${dest.to}`)\n        : this.resolvePathWithBase(fromPath, fromPath)\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : { ...prevParams, ...functionalUpdate(dest.params, prevParams) }\n\n      if (Object.keys(nextParams).length > 0) {\n        matches\n          ?.map((d) => this.looseRoutesById[d.routeId]!.options.stringifyParams)\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams) }\n          })\n      }\n\n      // encode all path params so the generated href is valid and stable\n      Object.keys(nextParams).forEach((key) => {\n        if (['*', '_splat'].includes(key)) {\n          // the splat/catch-all routes shouldn't have the '/' encoded out\n          nextParams[key] = encodeURI(nextParams[key])\n        } else {\n          nextParams[key] = encodeURIComponent(nextParams[key])\n        }\n      })\n\n      pathname = interpolatePath({\n        path: pathname,\n        params: nextParams ?? {},\n        leaveWildcards: false,\n        leaveParams: opts.leaveParams,\n      })\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters.length\n        ? preSearchFilters.reduce((prev, next) => next(prev), fromSearch)\n        : fromSearch\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) // Updater\n            : preSearchFilters.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? this.latestLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, this.latestLocation.hash)\n            : undefined\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? this.latestLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, this.latestLocation.state)\n            : {}\n\n      nextState = replaceEqualDeep(this.latestLocation.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        const foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          maskedDest = {\n            ...pick(opts, ['from']),\n            ...foundMask,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next.pathname, next.search)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext.pathname, maskedNext.search)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocation = async ({\n    startTransition,\n    viewTransition,\n    ...next\n  }: ParsedLocation & CommitLocationOptions) => {\n    const isSameUrl = this.latestLocation.href === next.href\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl) {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      if (viewTransition) {\n        this.shouldViewTransition = true\n      }\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.href,\n        nextHistory.state,\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    return this.latestLoadPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const location = this.buildLocation(rest as any)\n    return this.commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll,\n    })\n  }\n\n  navigate: NavigateFn = ({ from, to, ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    // const fromString = from !== undefined ? String(from) : from\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      from,\n      to,\n      // to: toString,\n    })\n  }\n\n  loadMatches = async ({\n    checkLatest,\n    location,\n    matches,\n    preload,\n  }: {\n    checkLatest: () => Promise<void> | undefined\n    location: ParsedLocation\n    matches: Array<AnyRouteMatch>\n    preload?: boolean\n  }): Promise<Array<MakeRouteMatch>> => {\n    let latestPromise\n    let firstBadMatchIndex: number | undefined\n\n    const updateMatch = (\n      id: string,\n      updater: (match: AnyRouteMatch) => AnyRouteMatch,\n      opts?: { remove?: boolean },\n    ) => {\n      let updated!: AnyRouteMatch\n      const isPending = this.state.pendingMatches?.find((d) => d.id === id)\n      const isMatched = this.state.matches.find((d) => d.id === id)\n\n      const matchesKey = isPending\n        ? 'pendingMatches'\n        : isMatched\n          ? 'matches'\n          : 'cachedMatches'\n\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: opts?.remove\n          ? s[matchesKey]?.filter((d) => d.id !== id)\n          : s[matchesKey]?.map((d) =>\n              d.id === id ? (updated = updater(d)) : d,\n            ),\n      }))\n\n      return updated\n    }\n\n    try {\n      await new Promise<void>((resolveAll, rejectAll) => {\n        ;(async () => {\n          try {\n            const handleRedirectAndNotFound = (\n              match: AnyRouteMatch,\n              err: any,\n            ) => {\n              if (isRedirect(err) || isNotFound(err)) {\n                updateMatch(match.id, (prev) => ({\n                  ...prev,\n                  status: isRedirect(err)\n                    ? 'redirected'\n                    : isNotFound(err)\n                      ? 'notFound'\n                      : 'error',\n                  isFetching: false,\n                  error: err,\n                }))\n\n                if (!(err as any).routeId) {\n                  ;(err as any).routeId = match.routeId\n                }\n\n                if (isRedirect(err)) {\n                  err = this.resolveRedirect(err)\n                  throw err\n                } else if (isNotFound(err)) {\n                  this.handleNotFound(matches, err)\n                  throw err\n                }\n              }\n            }\n\n            // Check each match middleware to see if the route can be accessed\n            // eslint-disable-next-line prefer-const\n            for (let [index, match] of matches.entries()) {\n              const parentMatch = matches[index - 1]\n              const route = this.looseRoutesById[match.routeId]!\n              const abortController = new AbortController()\n              let loadPromise = match.loadPromise\n\n              if (match.isFetching) {\n                continue\n              }\n\n              const previousResolve = loadPromise.resolve\n              // Create a new one\n              loadPromise = createControlledPromise<void>(\n                // Resolve the old when we we resolve the new one\n                previousResolve,\n              )\n\n              // Otherwise, load the route\n              matches[index] = match = updateMatch(match.id, (prev) => ({\n                ...prev,\n                isFetching: 'beforeLoad',\n                loadPromise,\n              }))\n\n              const handleSerialError = (err: any, routerCode: string) => {\n                err.routerCode = routerCode\n                firstBadMatchIndex = firstBadMatchIndex ?? index\n                handleRedirectAndNotFound(match, err)\n\n                try {\n                  route.options.onError?.(err)\n                } catch (errorHandlerErr) {\n                  err = errorHandlerErr\n                  handleRedirectAndNotFound(match, err)\n                }\n\n                matches[index] = match = {\n                  ...match,\n                  error: err,\n                  status: 'error',\n                  updatedAt: Date.now(),\n                  abortController: new AbortController(),\n                }\n              }\n\n              if (match.paramsError) {\n                handleSerialError(match.paramsError, 'PARSE_PARAMS')\n              }\n\n              if (match.searchError) {\n                handleSerialError(match.searchError, 'VALIDATE_SEARCH')\n              }\n\n              // if (match.globalNotFound && !preload) {\n              //   handleSerialError(notFound({ _global: true }), 'NOT_FOUND')\n              // }\n\n              try {\n                const parentContext =\n                  parentMatch?.context ?? this.options.context ?? {}\n\n                const pendingMs =\n                  route.options.pendingMs ?? this.options.defaultPendingMs\n                const pendingPromise =\n                  typeof pendingMs !== 'number' || pendingMs <= 0\n                    ? Promise.resolve()\n                    : new Promise<void>((r) => {\n                        if (pendingMs !== Infinity) setTimeout(r, pendingMs)\n                      })\n\n                const shouldPending =\n                  !this.isServer &&\n                  !preload &&\n                  (route.options.loader || route.options.beforeLoad) &&\n                  typeof pendingMs === 'number' &&\n                  (route.options.pendingComponent ??\n                    this.options.defaultPendingComponent)\n\n                if (shouldPending) {\n                  // If we might show a pending component, we need to wait for the\n                  // pending promise to resolve before we start showing that state\n                  pendingPromise.then(async () => {\n                    if ((latestPromise = checkLatest())) return latestPromise\n                    // Update the match and prematurely resolve the loadMatches promise so that\n                    // the pending component can start rendering\n                    resolveAll()\n                  })\n                }\n\n                const beforeLoadContext =\n                  (await route.options.beforeLoad?.({\n                    search: match.search,\n                    abortController,\n                    params: match.params,\n                    preload: !!preload,\n                    context: parentContext,\n                    location,\n                    navigate: (opts: any) =>\n                      this.navigate({ ...opts, from: match.pathname }),\n                    buildLocation: this.buildLocation,\n                    cause: preload ? 'preload' : match.cause,\n                  })) ?? ({} as any)\n\n                if ((latestPromise = checkLatest())) return latestPromise\n\n                if (\n                  isRedirect(beforeLoadContext) ||\n                  isNotFound(beforeLoadContext)\n                ) {\n                  handleSerialError(beforeLoadContext, 'BEFORE_LOAD')\n                }\n\n                const context = {\n                  ...parentContext,\n                  ...beforeLoadContext,\n                }\n\n                matches[index] = match = {\n                  ...match,\n                  routeContext: replaceEqualDeep(\n                    match.routeContext,\n                    beforeLoadContext,\n                  ),\n                  context: replaceEqualDeep(match.context, context),\n                  abortController,\n                }\n              } catch (err) {\n                handleSerialError(err, 'BEFORE_LOAD')\n                break\n              } finally {\n                updateMatch(match.id, () => match)\n              }\n            }\n\n            if ((latestPromise = checkLatest())) return latestPromise\n\n            const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n            const matchPromises: Array<Promise<any>> = []\n\n            await Promise.all(\n              validResolvedMatches.map(async (match, index) => {\n                const parentMatchPromise = matchPromises[index - 1]\n                const route = this.looseRoutesById[match.routeId]!\n\n                const loaderContext: LoaderFnContext = {\n                  params: match.params,\n                  deps: match.loaderDeps,\n                  preload: !!preload,\n                  parentMatchPromise,\n                  abortController: match.abortController,\n                  context: match.context,\n                  location,\n                  navigate: (opts) =>\n                    this.navigate({ ...opts, from: match.pathname } as any),\n                  cause: preload ? 'preload' : match.cause,\n                  route,\n                }\n\n                const fetch = async () => {\n                  const existing = getRouteMatch(this.state, match.id)!\n                  let lazyPromise = Promise.resolve()\n                  let componentsPromise = Promise.resolve() as Promise<any>\n                  let loaderPromise = existing.loaderPromise\n\n                  // If the Matches component rendered\n                  // the pending component and needs to show it for\n                  // a minimum duration, we''ll wait for it to resolve\n                  // before committing to the match and resolving\n                  // the loadPromise\n                  const potentialPendingMinPromise = async () => {\n                    const latestMatch = getRouteMatch(this.state, match.id)\n\n                    if (latestMatch?.minPendingPromise) {\n                      await latestMatch.minPendingPromise\n\n                      if ((latestPromise = checkLatest()))\n                        return await latestPromise\n\n                      updateMatch(latestMatch.id, (prev) => ({\n                        ...prev,\n                        minPendingPromise: undefined,\n                      }))\n                    }\n                  }\n\n                  try {\n                    if (match.isFetching === 'beforeLoad') {\n                      // If the user doesn't want the route to reload, just\n                      // resolve with the existing loader data\n\n                      // if (match.fetchCount && match.status === 'success') {\n                      //   resolve()\n                      // }\n\n                      // Otherwise, load the route\n                      matches[index] = match = updateMatch(\n                        match.id,\n                        (prev) => ({\n                          ...prev,\n                          isFetching: 'loader',\n                          fetchCount: match.fetchCount + 1,\n                        }),\n                      )\n\n                      lazyPromise =\n                        route.lazyFn?.().then((lazyRoute) => {\n                          Object.assign(route.options, lazyRoute.options)\n                        }) || Promise.resolve()\n\n                      // If for some reason lazy resolves more lazy components...\n                      // We'll wait for that before pre attempt to preload any\n                      // components themselves.\n                      componentsPromise = lazyPromise.then(() =>\n                        Promise.all(\n                          componentTypes.map(async (type) => {\n                            const component = route.options[type]\n\n                            if ((component as any)?.preload) {\n                              await (component as any).preload()\n                            }\n                          }),\n                        ),\n                      )\n\n                      // Lazy option can modify the route options,\n                      // so we need to wait for it to resolve before\n                      // we can use the options\n                      await lazyPromise\n\n                      if ((latestPromise = checkLatest()))\n                        return await latestPromise\n\n                      // Kick off the loader!\n                      loaderPromise = route.options.loader?.(loaderContext)\n\n                      matches[index] = match = updateMatch(\n                        match.id,\n                        (prev) => ({\n                          ...prev,\n                          loaderPromise,\n                        }),\n                      )\n                    }\n\n                    const loaderData = await loaderPromise\n                    if ((latestPromise = checkLatest()))\n                      return await latestPromise\n\n                    handleRedirectAndNotFound(match, loaderData)\n\n                    if ((latestPromise = checkLatest()))\n                      return await latestPromise\n\n                    await potentialPendingMinPromise()\n                    if ((latestPromise = checkLatest()))\n                      return await latestPromise\n\n                    const meta = route.options.meta?.({\n                      params: match.params,\n                      loaderData,\n                    })\n\n                    const headers = route.options.headers?.({\n                      loaderData,\n                    })\n\n                    matches[index] = match = updateMatch(match.id, (prev) => ({\n                      ...prev,\n                      error: undefined,\n                      status: 'success',\n                      isFetching: false,\n                      updatedAt: Date.now(),\n                      loaderData,\n                      meta,\n                      headers,\n                    }))\n                  } catch (e) {\n                    let error = e\n                    if ((latestPromise = checkLatest()))\n                      return await latestPromise\n\n                    await potentialPendingMinPromise()\n                    if ((latestPromise = checkLatest()))\n                      return await latestPromise\n\n                    handleRedirectAndNotFound(match, e)\n\n                    try {\n                      route.options.onError?.(e)\n                    } catch (onErrorError) {\n                      error = onErrorError\n                      handleRedirectAndNotFound(match, onErrorError)\n                    }\n\n                    matches[index] = match = updateMatch(match.id, (prev) => ({\n                      ...prev,\n                      error,\n                      status: 'error',\n                      isFetching: false,\n                    }))\n                  }\n\n                  // Last but not least, wait for the the component\n                  // to be preloaded before we resolve the match\n                  await componentsPromise\n\n                  if ((latestPromise = checkLatest()))\n                    return await latestPromise\n\n                  match.loadPromise.resolve()\n                }\n\n                // This is where all of the stale-while-revalidate magic happens\n                const age = Date.now() - match.updatedAt\n\n                const staleAge = preload\n                  ? route.options.preloadStaleTime ??\n                    this.options.defaultPreloadStaleTime ??\n                    30_000 // 30 seconds for preloads by default\n                  : route.options.staleTime ??\n                    this.options.defaultStaleTime ??\n                    0\n\n                const shouldReloadOption = route.options.shouldReload\n\n                // Default to reloading the route all the time\n                // Allow shouldReload to get the last say,\n                // if provided.\n                const shouldReload =\n                  typeof shouldReloadOption === 'function'\n                    ? shouldReloadOption(loaderContext)\n                    : shouldReloadOption\n\n                matches[index] = match = {\n                  ...match,\n                  preload:\n                    !!preload &&\n                    !this.state.matches.find((d) => d.id === match.id),\n                }\n\n                const fetchWithRedirectAndNotFound = async () => {\n                  try {\n                    await fetch()\n                  } catch (err) {\n                    if ((latestPromise = checkLatest()))\n                      return await latestPromise\n                    handleRedirectAndNotFound(match, err)\n                  }\n                }\n\n                // If the route is successful and still fresh, just resolve\n                if (\n                  match.status === 'success' &&\n                  (match.invalid || (shouldReload ?? age > staleAge))\n                ) {\n                  fetchWithRedirectAndNotFound()\n                  return\n                }\n\n                if (match.status !== 'success') {\n                  await fetchWithRedirectAndNotFound()\n                }\n              }),\n            )\n\n            if ((latestPromise = checkLatest())) return await latestPromise\n\n            resolveAll()\n          } catch (err) {\n            rejectAll(err)\n          }\n        })()\n      })\n    } catch (err) {\n      if (isRedirect(err) || isNotFound(err)) {\n        throw err\n      }\n    }\n\n    return matches\n  }\n\n  invalidate = () => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => ({\n      ...d,\n      invalid: true,\n      ...(d.status === 'error' ? ({ status: 'pending' } as const) : {}),\n    })\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    return this.load()\n  }\n\n  load = async (): Promise<void> => {\n    let resolveLoad!: (value: void) => void\n    let rejectLoad!: (reason: any) => void\n\n    const promise = new Promise<void>((resolve, reject) => {\n      resolveLoad = resolve\n      rejectLoad = reject\n    })\n\n    this.latestLoadPromise = promise\n\n    let latestPromise: Promise<void> | undefined | null\n\n    this.startReactTransition(async () => {\n      try {\n        const next = this.latestLocation\n        const prevLocation = this.state.resolvedLocation\n        const pathDidChange = prevLocation.href !== next.href\n\n        // Cancel any pending matches\n        this.cancelMatches()\n\n        this.emit({\n          type: 'onBeforeLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        let pendingMatches!: Array<AnyRouteMatch>\n        const previousMatches = this.state.matches\n\n        this.__store.batch(() => {\n          this.cleanCache()\n\n          // Match the routes\n          pendingMatches = this.matchRoutes(next.pathname, next.search)\n\n          // Ingest the new matches\n          // If a cached moved to pendingMatches, remove it from cachedMatches\n          this.__store.setState((s) => ({\n            ...s,\n            status: 'pending',\n            isLoading: true,\n            location: next,\n            pendingMatches,\n            cachedMatches: s.cachedMatches.filter((d) => {\n              return !pendingMatches.find((e) => e.id === d.id)\n            }),\n          }))\n        })\n\n        let redirect: ResolvedRedirect | undefined\n        let notFound: NotFoundError | undefined\n\n        const loadMatches = () =>\n          this.loadMatches({\n            matches: pendingMatches,\n            location: next,\n            checkLatest: () => this.checkLatest(promise),\n          })\n\n        // If we are on the server or non-first load on the client, await\n        // the loadMatches before transitioning\n        if (previousMatches.length || this.isServer) {\n          try {\n            await loadMatches()\n          } catch (err) {\n            if (isRedirect(err)) {\n              redirect = err as ResolvedRedirect\n            } else if (isNotFound(err)) {\n              notFound = err\n            }\n          }\n        } else {\n          // For client-only first loads, we need to start the transition\n          // immediately and load the matches in the background\n          loadMatches().catch((err) => {\n            // This also means that we need to handle any redirects\n            // that might happen during the load/transition\n            if (isRedirect(err)) {\n              this.navigate({ ...err, replace: true })\n            }\n            // Because our history listener isn't guaranteed to be mounted\n            // on the first load, we need to manually call load again\n            this.load()\n          })\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatches = previousMatches.filter(\n          (match) => !pendingMatches.find((d) => d.id === match.id),\n        )\n        const enteringMatches = pendingMatches.filter(\n          (match) => !previousMatches.find((d) => d.id === match.id),\n        )\n        const stayingMatches = previousMatches.filter((match) =>\n          pendingMatches.find((d) => d.id === match.id),\n        )\n\n        // Determine if we should start a view transition from the navigation\n        // or from the router default\n        const shouldViewTransition =\n          this.shouldViewTransition ?? this.options.defaultViewTransition\n\n        // Reset the view transition flag\n        delete this.shouldViewTransition\n\n        const apply = () => {\n          // this.viewTransitionPromise = createControlledPromise<true>()\n\n          // Commit the pending matches. If a previous match was\n          // removed, place it in the cachedMatches\n          this.__store.batch(() => {\n            this.__store.setState((s) => ({\n              ...s,\n              isLoading: false,\n              matches: s.pendingMatches!,\n              pendingMatches: undefined,\n              cachedMatches: [\n                ...s.cachedMatches,\n                ...exitingMatches.filter((d) => d.status !== 'error'),\n              ],\n              statusCode:\n                redirect?.statusCode || notFound\n                  ? 404\n                  : s.matches.some((d) => d.status === 'error')\n                    ? 500\n                    : 200,\n              redirect,\n            }))\n            this.cleanCache()\n          })\n\n          //\n          ;(\n            [\n              [exitingMatches, 'onLeave'],\n              [enteringMatches, 'onEnter'],\n              [stayingMatches, 'onStay'],\n            ] as const\n          ).forEach(([matches, hook]) => {\n            matches.forEach((match) => {\n              this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n            })\n          })\n\n          resolveLoad()\n\n          // return this.viewTransitionPromise\n        }\n\n        // Attempt to start a view transition (or just apply the changes if we can't)\n        ;(shouldViewTransition && typeof document !== 'undefined'\n          ? document\n          : undefined\n        )\n          // @ts-expect-error\n          ?.startViewTransition?.(apply) || apply()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        console.error('Load Error', err)\n\n        rejectLoad(err)\n      }\n    })\n\n    return this.latestLoadPromise\n  }\n\n  resolveRedirect = (err: AnyRedirect): ResolvedRedirect => {\n    const redirect = err as ResolvedRedirect\n\n    if (!redirect.href) {\n      redirect.href = this.buildLocation(redirect as any).href\n    }\n\n    return redirect\n  }\n\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter((d) => {\n          const route = this.looseRoutesById[d.routeId]!\n\n          if (!route.options.loader) {\n            return false\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime =\n            (d.preload\n              ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime\n              : route.options.gcTime ?? this.options.defaultGcTime) ??\n            5 * 60 * 1000\n\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime\n        }),\n      }\n    })\n  }\n\n  preloadRoute = async <\n    TFrom extends RoutePaths<TRouteTree> | string = string,\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n    TMaskTo extends string = '',\n  >(\n    opts: NavigateOptions<\n      Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>,\n      TFrom,\n      TTo,\n      TMaskFrom,\n      TMaskTo\n    >,\n  ): Promise<Array<AnyRouteMatch> | undefined> => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n      preload: true,\n    })\n\n    const loadedMatchIds = Object.fromEntries(\n      [\n        ...this.state.matches,\n        ...(this.state.pendingMatches ?? []),\n        ...this.state.cachedMatches,\n      ].map((d) => [d.id, true]),\n    )\n\n    this.__store.batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    // If the preload leaf match is the same as the current or pending leaf match,\n    // do not preload as it could cause a mutation of the current route.\n    // The user should specify proper loaderDeps (which are used to uniquely identify a route)\n    // to trigger preloads for routes with the same pathname, but different deps\n\n    const leafMatch = last(matches)\n    const currentLeafMatch = last(this.state.matches)\n    const pendingLeafMatch = last(this.state.pendingMatches ?? [])\n\n    if (\n      leafMatch &&\n      (currentLeafMatch?.id === leafMatch.id ||\n        pendingLeafMatch?.id === leafMatch.id)\n    ) {\n      return undefined\n    }\n\n    try {\n      matches = await this.loadMatches({\n        matches,\n        location: next,\n        preload: true,\n        checkLatest: () => undefined,\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        return await this.preloadRoute({\n          fromSearch: next.search,\n          from: next.pathname,\n          ...(err as any),\n        })\n      }\n      // Preload errors are not fatal, but we should still log them\n      console.error(err)\n      return undefined\n    }\n  }\n\n  matchRoute = <\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<\n      Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>,\n      TFrom,\n      TTo\n    >,\n    opts?: MatchRouteOptions,\n  ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, true)) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  // We use a token -> weak map to keep track of deferred promises\n  // that are registered on the server and need to be resolved\n  registeredDeferredsIds = new Map<string, {}>()\n  registeredDeferreds = new WeakMap<{}, DeferredPromiseState<any>>()\n\n  getDeferred = (uid: string) => {\n    const token = this.registeredDeferredsIds.get(uid)\n\n    if (!token) {\n      return undefined\n    }\n\n    return this.registeredDeferreds.get(token)\n  }\n\n  /**\n   * @deprecated Please inject your own html using the `injectHtml` method\n   */\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    warning(\n      false,\n      `The dehydrateData method is deprecated. Please use the injectHtml method to inject your own data.`,\n    )\n\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script id='${id}' suppressHydrationWarning>\n  window[\"__TSR_DEHYDRATED__${escapeJSON(\n    strKey,\n  )}\"] = ${JSON.stringify(this.options.transformer.stringify(data))}\n</script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  /**\n   * @deprecated Please extract your own data from scripts injected using the `injectHtml` method\n   */\n  hydrateData = <T = unknown>(key: any) => {\n    warning(\n      false,\n      `The hydrateData method is deprecated. Please use the extractHtml method to extract your own data.`,\n    )\n\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return this.options.transformer.parse(\n        window[`__TSR_DEHYDRATED__${strKey}` as any] as unknown as string,\n      ) as T\n    }\n\n    return undefined\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    const pickError =\n      this.options.errorSerializer?.serialize ?? defaultSerializeError\n\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) => ({\n          ...pick(d, ['id', 'status', 'updatedAt', 'loaderData']),\n          // If an error occurs server-side during SSRing,\n          // send a small subset of the error to the client\n          error: d.error\n            ? {\n                data: pickError(d.error),\n                __isServerError: true,\n              }\n            : undefined,\n        })),\n      },\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: string) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__?.data\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = this.options.transformer.parse(_ctx) as HydrationCtx\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    const matches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    ).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      const route = this.looseRoutesById[match.routeId]!\n\n      const assets =\n        dehydratedMatch.status === 'notFound' ||\n        dehydratedMatch.status === 'redirected'\n          ? {}\n          : {\n              meta: route.options.meta?.({\n                params: match.params,\n                loaderData: dehydratedMatch.loaderData,\n              }),\n              links: route.options.links?.(),\n              scripts: route.options.scripts?.(),\n            }\n\n      return {\n        ...match,\n        ...dehydratedMatch,\n        ...assets,\n      }\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n      }\n    })\n  }\n\n  handleNotFound = (matches: Array<AnyRouteMatch>, err: NotFoundError) => {\n    const matchesByRouteId = Object.fromEntries(\n      matches.map((match) => [match.routeId, match]),\n    ) as Record<string, AnyRouteMatch>\n\n    // Start at the route that errored or default to the root route\n    let routeCursor =\n      (err.global\n        ? this.looseRoutesById[rootRouteId]\n        : this.looseRoutesById[err.routeId]) ||\n      this.looseRoutesById[rootRouteId]!\n\n    // Go up the tree until we find a route with a notFoundComponent or we hit the root\n    while (\n      !routeCursor.options.notFoundComponent &&\n      !this.options.defaultNotFoundComponent &&\n      routeCursor.id !== rootRouteId\n    ) {\n      routeCursor = routeCursor.parentRoute\n\n      invariant(\n        routeCursor,\n        'Found invalid route tree while trying to find not-found handler.',\n      )\n    }\n\n    const match = matchesByRouteId[routeCursor.id]\n\n    invariant(match, 'Could not find match for route: ' + routeCursor.id)\n\n    // Assign the error to the match\n    Object.assign(match, {\n      status: 'notFound',\n      error: err,\n      isFetching: false,\n    } as AnyRouteMatch)\n  }\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: { ...location },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n", "import { defaultSerializeError } from './router'\n\nexport type DeferredPromiseState<T> = {\n  uid: string\n  resolve?: () => void\n  promise?: Promise<void>\n  __resolvePromise?: () => void\n} & (\n  | {\n      status: 'pending'\n      data?: T\n      error?: unknown\n    }\n  | {\n      status: 'success'\n      data: T\n    }\n  | {\n      status: 'error'\n      data?: T\n      error: unknown\n    }\n)\n\nexport type DeferredPromise<T> = Promise<T> & {\n  __deferredState: DeferredPromiseState<T>\n}\n\nexport function defer<T>(\n  _promise: Promise<T>,\n  options?: {\n    serializeError?: typeof defaultSerializeError\n  },\n) {\n  const promise = _promise as DeferredPromise<T>\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!promise.__deferredState) {\n    promise.__deferredState = {\n      uid: Math.random().toString(36).slice(2),\n      status: 'pending',\n    }\n\n    const state = promise.__deferredState\n\n    promise\n      .then((data) => {\n        state.status = 'success' as any\n        state.data = data\n      })\n      .catch((error) => {\n        state.status = 'error' as any\n        state.error = {\n          data: (options?.serializeError ?? defaultSerializeError)(error),\n          __isServerError: true,\n        }\n      })\n  }\n\n  return promise\n}\n\nexport function isDehydratedDeferred(obj: any): boolean {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    !(obj instanceof Promise) &&\n    !obj.then &&\n    '__deferredState' in obj\n  )\n}\n", "import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { useRouter } from './useRouter'\nimport { defaultSerializeError } from './router'\nimport { isDehydratedDeferred } from './defer'\nimport { defaultDeserializeError, isServerSideError } from './Matches'\nimport type { DeferredPromise } from './defer'\n\nexport type AwaitOptions<T> = {\n  promise: DeferredPromise<T>\n}\n\nexport function useAwaited<T>({ promise }: AwaitOptions<T>): [T] {\n  const router = useRouter()\n  // const rerender = React.useReducer((x) => x + 1, 0)[1]\n\n  const state = promise.__deferredState\n\n  // Dehydrated promises only\n  // Successful or errored deferred promises mean they\n  // were resolved on the server and no further action is needed\n  if (isDehydratedDeferred(promise) && state.status === 'pending') {\n    const streamedData = (window as any)[`__TSR__DEFERRED__${state.uid}`]\n\n    if (streamedData) {\n      Object.assign(state, router.options.transformer.parse(streamedData))\n    } else {\n      let token = router.registeredDeferredsIds.get(state.uid)\n\n      // If we haven't yet, create a promise and resolver that our streamed HTML can use\n      // when the client-side data is streamed in and ready.\n      if (!token) {\n        token = {}\n        router.registeredDeferredsIds.set(state.uid, token)\n        router.registeredDeferreds.set(token, state)\n\n        Object.assign(state, {\n          resolve: () => {\n            state.__resolvePromise?.()\n            // rerender()\n          },\n          promise: new Promise((r) => {\n            state.__resolvePromise = r as any\n          }),\n          __resolvePromise: () => {},\n        })\n      }\n    }\n  }\n\n  // If the promise is pending, always throw the state.promise\n  // For originating promises, this will be the original promise\n  // For dehydrated promises, this will be the placeholder promise\n  // that will be resolved when the server sends the real data\n  if (state.status === 'pending') {\n    throw isDehydratedDeferred(promise) ? state.promise : promise\n  }\n\n  // If we are the originator of the promise,\n  // inject the state into the HTML stream\n  if (!isDehydratedDeferred(promise)) {\n    router.injectHtml(`<script class='tsr_deferred_data'>window.__TSR__DEFERRED__${state.uid} = ${JSON.stringify(router.options.transformer.stringify(state))}</script>\n<script class='tsr_deferred_handler'>\n  if (window.__TSR__ROUTER__) {\n    let deferred = window.__TSR__ROUTER__.getDeferred('${state.uid}')\n    if (deferred) deferred.resolve(window.__TSR__DEFERRED__${state.uid})\n  }\n  document.querySelectorAll('.tsr_deferred_handler').forEach((el) => el.parentElement.removeChild(el))\n</script>`)\n  }\n\n  if (state.status === 'error') {\n    if (typeof document !== 'undefined') {\n      if (isServerSideError(state.error)) {\n        throw (\n          router.options.errorSerializer?.deserialize ?? defaultDeserializeError\n        )(state.error.data as any)\n      } else {\n        warning(\n          false,\n          \"Encountered a server-side error that doesn't fit the expected shape\",\n        )\n        throw state.error\n      }\n    } else {\n      throw {\n        data: (\n          router.options.errorSerializer?.serialize ?? defaultSerializeError\n        )(state.error),\n        __isServerError: true,\n      }\n    }\n  }\n\n  return [promise.__deferredState.data as any]\n}\n\nexport function Await<T>(\n  props: AwaitOptions<T> & {\n    fallback?: React.ReactNode\n    children: (result: T) => React.ReactNode\n  },\n) {\n  const inner = <AwaitInner {...props} />\n  if (props.fallback) {\n    return <React.Suspense fallback={props.fallback}>{inner}</React.Suspense>\n  }\n  return inner\n}\n\nfunction AwaitInner<T>(\n  props: AwaitOptions<T> & {\n    fallback?: React.ReactNode\n    children: (result: T) => React.ReactNode\n  },\n) {\n  const awaited = useAwaited(props)\n  return props.children(...awaited) as React.JSX.Element\n}\n", "import warning from 'tiny-warning'\nimport { createRoute } from './route'\nimport { useLoaderData, useLoaderDeps, useMatch } from './Matches'\nimport { useSearch } from './useSearch'\nimport { useParams } from './useParams'\nimport { useNavigate } from './useNavigate'\nimport type { ParsePathParams } from './link'\nimport type {\n  AnyContext,\n  AnyPathParams,\n  AnyRoute,\n  AnySearchSchema,\n  FileBaseRouteOptions,\n  MergeFromFromParent,\n  ResolveFullPath,\n  ResolveFullSearchSchema,\n  ResolveFullSearchSchemaInput,\n  RootRouteId,\n  Route,\n  RouteConstraints,\n  RouteContext,\n  RouteLoaderFn,\n  SearchSchemaInput,\n  TrimPathLeft,\n  UpdatableRouteOptions,\n} from './route'\nimport type { Assign, IsAny } from './utils'\nimport type { MakeRouteMatch } from './Matches'\nimport type { NoInfer } from '@tanstack/react-store'\nimport type { RegisteredRouter } from './router'\nimport type { RouteById, RouteIds } from './routeInfo'\n\nexport interface FileRoutesByPath {\n  // '/': {\n  //   parentRoute: typeof rootRoute\n  // }\n}\n\ntype Replace<\n  TValue extends string,\n  TFrom extends string,\n  TTo extends string,\n  TAcc extends string = '',\n> = TValue extends `${infer Start}${TFrom}${infer Rest}`\n  ? Replace<Rest, TFrom, TTo, `${TAcc}${Start}${TTo}`>\n  : `${TAcc}${TValue}`\n\nexport type TrimLeft<\n  TValue extends string,\n  TStartsWith extends string,\n> = TValue extends `${TStartsWith}${infer U}` ? U : TValue\n\nexport type TrimRight<\n  TValue extends string,\n  TEndsWith extends string,\n> = TValue extends `${infer U}${TEndsWith}` ? U : TValue\n\nexport type Trim<TValue extends string, TFind extends string> = TrimLeft<\n  TrimRight<TValue, TFind>,\n  TFind\n>\n\nexport type RemoveUnderScores<T extends string> = Replace<\n  Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>,\n  '/_',\n  '/'\n>\n\ntype RemoveRouteGroups<T extends string> =\n  T extends `${infer Before}(${string})${infer After}`\n    ? RemoveRouteGroups<`${Before}${After}`>\n    : T\n\ntype NormalizeSlashes<T extends string> =\n  T extends `${infer Before}//${infer After}`\n    ? NormalizeSlashes<`${Before}/${After}`>\n    : T\n\nexport type ResolveFilePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = TParentRoute['id'] extends RootRouteId\n  ? TrimPathLeft<TFilePath>\n  : TFilePath extends `${TParentRoute['types']['customId']}${infer TRest}`\n    ? TRest\n    : TFilePath\n\nexport type FileRoutePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n  TResolvedFilePath = ResolveFilePath<TParentRoute, TFilePath>,\n> = TResolvedFilePath extends `_${string}`\n  ? ''\n  : TResolvedFilePath extends `/_${string}`\n    ? ''\n    : TResolvedFilePath\n\nexport function createFileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = NormalizeSlashes<\n    RemoveRouteGroups<TFilePath>\n  >,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    NormalizeSlashes<RemoveRouteGroups<RemoveUnderScores<TPath>>>\n  >,\n>(path: TFilePath) {\n  return new FileRoute<TFilePath, TParentRoute, TId, TPath, TFullPath>(path, {\n    silent: true,\n  }).createRoute\n}\n\n/** \n  @deprecated It's no longer recommended to use the `FileRoute` class directly.\n  Instead, use `createFileRoute('/path/to/file')(options)` to create a file route.\n*/\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = TFilePath,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    RemoveUnderScores<TPath>\n  >,\n> {\n  silent?: boolean\n\n  constructor(\n    public path: TFilePath,\n    _opts?: { silent: boolean },\n  ) {\n    this.silent = _opts?.silent\n  }\n\n  createRoute = <\n    TSearchSchemaInput extends RouteConstraints['TSearchSchema'] = {},\n    TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n    TSearchSchemaUsed = TSearchSchemaInput extends SearchSchemaInput\n      ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n      : TSearchSchema,\n    TFullSearchSchemaInput = ResolveFullSearchSchemaInput<\n      TParentRoute,\n      TSearchSchemaUsed\n    >,\n    TFullSearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>,\n    TParams = Record<ParsePathParams<TPath>, string>,\n    TAllParams = MergeFromFromParent<\n      TParentRoute['types']['allParams'],\n      TParams\n    >,\n    TRouteContextReturn extends\n      RouteConstraints['TRouteContext'] = RouteContext,\n    TRouteContext = [TRouteContextReturn] extends [never]\n      ? RouteContext\n      : TRouteContextReturn,\n    TAllContext = Assign<\n      IsAny<TParentRoute['types']['allContext'], {}>,\n      TRouteContext\n    >,\n    TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderDataReturn = unknown,\n    TLoaderData = [TLoaderDataReturn] extends [never]\n      ? undefined\n      : TLoaderDataReturn,\n    TChildren extends RouteConstraints['TChildren'] = unknown,\n  >(\n    options?: FileBaseRouteOptions<\n      TParentRoute,\n      TPath,\n      TSearchSchemaInput,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContextReturn,\n      TRouteContext,\n      TRouterContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderDataReturn\n    > &\n      UpdatableRouteOptions<\n        TId,\n        TAllParams,\n        TFullSearchSchema,\n        TLoaderData,\n        TAllContext,\n        TRouteContext,\n        TLoaderDeps\n      >,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchSchemaInput,\n    TSearchSchema,\n    TSearchSchemaUsed,\n    TFullSearchSchemaInput,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContextReturn,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderDataReturn,\n    TLoaderData,\n    TChildren\n  > => {\n    warning(\n      this.silent,\n      'FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead.',\n    )\n    const route = createRoute(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n\n/** \n  @deprecated It's recommended not to split loaders into separate files.\n  Instead, place the loader function in the the main route file, inside the\n  `createFileRoute('/path/to/file)(options)` options.\n*/\nexport function FileRouteLoader<\n  TFilePath extends keyof FileRoutesByPath,\n  TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute'],\n>(\n  _path: TFilePath,\n): <TLoaderData>(\n  loaderFn: RouteLoaderFn<\n    TRoute['types']['allParams'],\n    TRoute['types']['loaderDeps'],\n    TRoute['types']['allContext'],\n    TRoute['types']['routeContext'],\n    TLoaderData\n  >,\n) => RouteLoaderFn<\n  TRoute['types']['allParams'],\n  TRoute['types']['loaderDeps'],\n  TRoute['types']['allContext'],\n  TRoute['types']['routeContext'],\n  NoInfer<TLoaderData>\n> {\n  warning(\n    false,\n    `FileRouteLoader is deprecated and will be removed in the next major version. Please place the loader function in the the main route file, inside the \\`createFileRoute('/path/to/file')(options)\\` options`,\n  )\n  return (loaderFn) => loaderFn\n}\n\nexport type LazyRouteOptions = Pick<\n  UpdatableRouteOptions<\n    string,\n    AnyPathParams,\n    AnySearchSchema,\n    {},\n    AnyContext,\n    AnyContext,\n    {}\n  >,\n  'component' | 'errorComponent' | 'pendingComponent' | 'notFoundComponent'\n>\n\nexport class LazyRoute<TRoute extends AnyRoute> {\n  options: {\n    id: string\n  } & LazyRouteOptions\n\n  constructor(\n    opts: {\n      id: string\n    } & LazyRouteOptions,\n  ) {\n    this.options = opts\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  useMatch = <\n    TRouteMatch = MakeRouteMatch<\n      RegisteredRouter['routeTree'],\n      TRoute['types']['id']\n    >,\n    TSelected = TRouteMatch,\n  >(opts?: {\n    select?: (match: TRouteMatch) => TSelected\n  }): TSelected => {\n    return useMatch({ select: opts?.select, from: this.options.id })\n  }\n\n  useRouteContext = <TSelected = TRoute['types']['allContext']>(opts?: {\n    select?: (s: TRoute['types']['allContext']) => TSelected\n  }): TSelected => {\n    return useMatch({\n      from: this.options.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    })\n  }\n\n  useSearch = <TSelected = TRoute['types']['fullSearchSchema']>(opts?: {\n    select?: (s: TRoute['types']['fullSearchSchema']) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.options.id })\n  }\n\n  useParams = <TSelected = TRoute['types']['allParams']>(opts?: {\n    select?: (s: TRoute['types']['allParams']) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.options.id })\n  }\n\n  useLoaderDeps = <TSelected = TRoute['types']['loaderDeps']>(opts?: {\n    select?: (s: TRoute['types']['loaderDeps']) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.options.id } as any)\n  }\n\n  useLoaderData = <TSelected = TRoute['types']['loaderData']>(opts?: {\n    select?: (s: TRoute['types']['loaderData']) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.options.id } as any)\n  }\n\n  useNavigate = () => {\n    return useNavigate({ from: this.options.id })\n  }\n}\n\nexport function createLazyRoute<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n>(id: TId) {\n  return (opts: LazyRouteOptions) => {\n    return new LazyRoute<TRoute>({ id: id as any, ...opts })\n  }\n}\n\nexport function createLazyFileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute'],\n>(path: TFilePath) {\n  const id = removeGroups(path)\n  return (opts: LazyRouteOptions) => new LazyRoute<TRoute>({ id, ...opts })\n}\n\nconst routeGroupPatternRegex = /\\(.+\\)/g\n\nfunction removeGroups(s: string) {\n  return s.replaceAll(routeGroupPatternRegex, '').replaceAll('//', '/')\n}\n", "import * as React from 'react'\nimport type { AsyncRouteComponent } from './route'\n\n// If the load fails due to module not found, it may mean a new version of\n// the build was deployed and the user's browser is still using an old version.\n// If this happens, the old version in the user's browser would have an outdated\n// URL to the lazy module.\n// In that case, we want to attempt one window refresh to get the latest.\nfunction isModuleNotFoundError(error: any): boolean {\n  return (\n    typeof error?.message === 'string' &&\n    /Failed to fetch dynamically imported module/.test(error.message)\n  )\n}\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any> & {\n    moduleNotFoundError?: Error\n  }\n\n  const load = () => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!loadPromise) {\n      loadPromise = importer().catch((error) => {\n        if (isModuleNotFoundError(error)) {\n          // We don't want an error thrown from preload in this case, because\n          // there's nothing we want to do about module not found during preload.\n          // Record the error, recover the promise with a null return,\n          // and we will attempt module not found resolution during the render path.\n\n          loadPromise.moduleNotFoundError = error\n\n          return null\n        }\n        throw error\n      })\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = React.lazy(async () => {\n    try {\n      const promise = load()\n\n      // Now that we're out of preload and into actual render path,\n      // throw the error if it was a module not found error during preload\n      if (promise.moduleNotFoundError) {\n        throw promise.moduleNotFoundError\n      }\n      const moduleExports = await promise\n\n      const comp = moduleExports[exportName ?? 'default']\n      return {\n        default: comp,\n      }\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        isModuleNotFoundError(error) &&\n        typeof window !== 'undefined' &&\n        typeof sessionStorage !== 'undefined'\n      ) {\n        // Again, we want to reload one time on module not found error and not enter\n        // a reload loop if there is some other issue besides an old deploy.\n        // That's why we store our reload attempt in sessionStorage.\n        // Use error.message as key because it contains the module path that failed.\n        const storageKey = `tanstack_router_reload:${error.message}`\n        if (!sessionStorage.getItem(storageKey)) {\n          sessionStorage.setItem(storageKey, '1')\n          window.location.reload()\n\n          // Return empty component while we wait for window to reload\n          return {\n            default: () => null,\n          }\n        }\n      }\n      throw error\n    }\n  })\n\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n", "import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport { useMatch } from './Matches'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { deepEqual, exactPathTest, functionalUpdate } from './utils'\nimport type { AnyRouter, ParsedLocation } from '.'\nimport type { HistoryState } from '@tanstack/history'\nimport type { Trim } from './fileRoute'\nimport type { AnyRoute, RootSearchSchema } from './route'\nimport type {\n  RouteByPath,\n  RouteByToPath,\n  RoutePaths,\n  RoutePathsAutoComplete,\n  RouteToPath,\n} from './routeInfo'\nimport type { RegisteredRouter } from './router'\nimport type {\n  Expand,\n  MakeDifferenceOptional,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  Updater,\n  WithoutEmpty,\n} from './utils'\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n    ? `${CleanPath<L>}/`\n    : T extends `//${infer L}`\n      ? `/${CleanPath<L>}`\n      : T\n\nexport type Split<TValue, TIncludeTrailingSlash = true> = TValue extends unknown\n  ? string extends TValue\n    ? Array<string>\n    : TValue extends string\n      ? CleanPath<TValue> extends ''\n        ? []\n        : TIncludeTrailingSlash extends true\n          ? CleanPath<TValue> extends `${infer T}/`\n            ? [...Split<T>, '/']\n            : CleanPath<TValue> extends `/${infer U}`\n              ? Split<U>\n              : CleanPath<TValue> extends `${infer T}/${infer U}`\n                ? [...Split<T>, ...Split<U>]\n                : [TValue]\n          : CleanPath<TValue> extends `${infer T}/${infer U}`\n            ? [...Split<T>, ...Split<U>]\n            : TValue extends string\n              ? [TValue]\n              : never\n      : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}`\n    ? L extends ''\n      ? '_splat'\n      : L\n    : never]: K\n}\n\nexport type Join<T, TDelimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n    ? L\n    : T extends [\n          infer L extends string,\n          ...infer Tail extends [...Array<string>],\n        ]\n      ? CleanPath<`${L}${TDelimiter}${Join<Tail>}`>\n      : never\n\nexport type Last<T extends Array<any>> = T extends [...infer _, infer L]\n  ? L\n  : never\n\nexport type RemoveTrailingSlashes<T> = T extends `${infer R}/` ? R : T\n\nexport type RemoveLeadingSlashes<T> = T extends `/${infer R}` ? R : T\n\nexport type ResolvePaths<TRouter extends AnyRouter, TSearchPath> =\n  RouteByPath<\n    TRouter['routeTree'],\n    RemoveTrailingSlashes<TSearchPath>\n  > extends never\n    ? RouteToPath<TRouter, TRouter['routeTree']>\n    : RouteToPath<\n        TRouter,\n        RouteByPath<TRouter['routeTree'], RemoveTrailingSlashes<TSearchPath>>\n      >\n\nexport type SearchPaths<\n  TRouter extends AnyRouter,\n  TSearchPath extends string,\n  TPaths = ResolvePaths<TRouter, TSearchPath>,\n> = TPaths extends `${RemoveTrailingSlashes<TSearchPath>}${infer TRest}`\n  ? TRest\n  : never\n\nexport type SearchRelativePathAutoComplete<\n  TRouter extends AnyRouter,\n  TTo extends string,\n  TSearchPath extends string,\n> = `${TTo}/${RemoveLeadingSlashes<SearchPaths<TRouter, TSearchPath>>}`\n\nexport type RelativeToParentPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n  TResolvedPath extends string = RemoveTrailingSlashes<\n    ResolveRelativePath<TFrom, TTo>\n  >,\n> =\n  | SearchRelativePathAutoComplete<TRouter, TTo, TResolvedPath>\n  | (TResolvedPath extends '' ? never : `${TTo}/../`)\n\nexport type RelativeToCurrentPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n  TRestTo extends string,\n  TResolvedPath extends\n    string = RemoveTrailingSlashes<`${RemoveTrailingSlashes<TFrom>}/${RemoveLeadingSlashes<TRestTo>}`>,\n> = SearchRelativePathAutoComplete<TRouter, TTo, TResolvedPath>\n\nexport type AbsolutePathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n> =\n  | (string extends TFrom\n      ? './'\n      : TFrom extends `/`\n        ? never\n        : SearchPaths<TRouter, TFrom> extends ''\n          ? never\n          : './')\n  | (string extends TFrom ? '../' : TFrom extends `/` ? never : '../')\n  | RouteToPath<TRouter, TRouter['routeTree']>\n  | (TFrom extends '/'\n      ? never\n      : string extends TFrom\n        ? RemoveLeadingSlashes<RouteToPath<TRouter, TRouter['routeTree']>>\n        : RemoveLeadingSlashes<SearchPaths<TRouter, TFrom>>)\n\nexport type RelativeToPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n> = TTo extends `..${string}`\n  ? RelativeToParentPathAutoComplete<TRouter, TFrom, RemoveTrailingSlashes<TTo>>\n  : TTo extends `./${infer TRestTTo}`\n    ? RelativeToCurrentPathAutoComplete<\n        TRouter,\n        TFrom,\n        RemoveTrailingSlashes<TTo>,\n        TRestTTo\n      >\n    : AbsolutePathAutoComplete<TRouter, TFrom>\n\nexport type NavigateOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  /** @deprecated All navigations now use startTransition under the hood */\n  startTransition?: boolean\n  // if set to `true`, the router will wrap the resulting navigation in a document.startViewTransition() call.\n  viewTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouter, TFrom, TTo> & {\n  _fromLocation?: ParsedLocation\n  mask?: ToMaskOptions<TRouter, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRouter = RegisteredRouter,\n  TMaskFrom extends RoutePaths<TRouteTree['routeTree']> | string = string,\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n> = {\n  to?: ToPathOption<TRouter, TFrom, TTo> & {}\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: RoutePathsAutoComplete<TRouter['routeTree'], TFrom> & {}\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n} & SearchParamOptions<TRouter, TFrom, TTo> &\n  PathParamOptions<TRouter, TFrom, TTo>\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\ntype ParamVariant = 'PATH' | 'SEARCH'\n\ntype ExcludeRootSearchSchema<T, TExcluded = Exclude<T, RootSearchSchema>> = [\n  TExcluded,\n] extends [never]\n  ? {}\n  : TExcluded\n\nexport type ResolveRoute<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo,\n  TPath = string extends TFrom\n    ? TTo\n    : string extends TTo\n      ? TFrom\n      : ResolveRelativePath<TFrom, TTo>,\n> = TPath extends string\n  ? string extends TTo\n    ? RouteByPath<TRouter['routeTree'], TPath>\n    : RouteByToPath<TRouter, TPath>\n  : never\n\ntype PostProcessParams<\n  T,\n  TParamVariant extends ParamVariant,\n> = TParamVariant extends 'SEARCH' ? ExcludeRootSearchSchema<T> : T\n\ntype ResolveFromParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n> = PostProcessParams<\n  RouteByPath<TRouter['routeTree'], TFrom>['types'][TParamVariant extends 'PATH'\n    ? 'allParams'\n    : 'fullSearchSchema'],\n  TParamVariant\n>\n\ntype ResolveToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n  TRoute extends AnyRoute = ResolveRoute<TRouter, TFrom, TTo>,\n> = PostProcessParams<\n  TRoute['types'][TParamVariant extends 'PATH'\n    ? 'allParams'\n    : 'fullSearchSchemaInput'],\n  TParamVariant\n>\n\ntype ResolveRelativeToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n  TToParams = ResolveToParams<TRouter, TParamVariant, TFrom, TTo>,\n> = TParamVariant extends 'SEARCH'\n  ? TToParams\n  : string extends TFrom\n    ? TToParams\n    : MakeDifferenceOptional<\n        ResolveFromParams<TRouter, TParamVariant, TFrom>,\n        TToParams\n      >\n\ntype MakeOptionalParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> = TParamVariant extends 'SEARCH'\n  ? {\n      search?:\n        | true\n        | (ParamsReducer<\n            Expand<ResolveFromParams<TRouter, TParamVariant, TFrom>>,\n            Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n          > & {})\n    }\n  : {\n      params?:\n        | true\n        | (ParamsReducer<\n            Expand<ResolveFromParams<TRouter, TParamVariant, TFrom>>,\n            Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n          > & {})\n    }\n\ntype MakeRequiredParamsReducer<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TToParams,\n  TFromParams = ResolveFromParams<TRouter, TParamVariant, TFrom>,\n> =\n  | ([TFromParams] extends [WithoutEmpty<PickRequired<TToParams>>]\n      ? true\n      : never)\n  | ParamsReducer<Expand<TFromParams>, TToParams>\n\nexport type MakeRequiredParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> = TParamVariant extends 'SEARCH'\n  ? {\n      search: Expand<\n        MakeRequiredParamsReducer<\n          TRouter,\n          TParamVariant,\n          TFrom,\n          Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n        >\n      > & {}\n    }\n  : {\n      params: Expand<\n        MakeRequiredParamsReducer<\n          TRouter,\n          TParamVariant,\n          TFrom,\n          Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n        >\n      > & {}\n    }\n\nexport type IsRequiredParams<TParams> = keyof TParams extends infer K extends\n  keyof TParams\n  ? K extends any\n    ? undefined extends TParams[K]\n      ? never\n      : true\n    : never\n  : never\n\nexport type IsRequired<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> = string extends TTo\n  ? string extends TFrom\n    ? never\n    : IsRequiredParams<\n        ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>\n      >\n  : IsRequiredParams<\n      ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>\n    >\n\nexport type ParamOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo extends string,\n  TParamVariant extends ParamVariant,\n> =\n  IsRequired<TRouter, TParamVariant, TFrom, TTo> extends never\n    ? MakeOptionalParams<TRouter, TParamVariant, TFrom, TTo>\n    : MakeRequiredParams<TRouter, TParamVariant, TFrom, TTo>\n\nexport type SearchParamOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo extends string,\n> = ParamOptions<TRouter, TFrom, TTo, 'SEARCH'>\n\nexport type PathParamOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo extends string,\n> = ParamOptions<TRouter, TFrom, TTo, 'PATH'>\n\nexport type ToPathOption<\n  TRouter extends AnyRouter = AnyRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = string,\n> =\n  | CheckPath<TRouter, TTo, never, TFrom, TTo>\n  | RelativeToPathAutoComplete<\n      TRouter,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckPath<TRouter extends AnyRouter, TPass, TFail, TFrom, TTo> =\n  ResolveRoute<TRouter, TFrom, TTo> extends never ? TFail : TPass\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n        ? Join<[TFrom, '/']>\n        : TTo extends `./${infer TRest}`\n          ? ResolveRelativePath<TFrom, TRest>\n          : TTo extends `/${infer TRest}`\n            ? TTo\n            : Split<TTo> extends ['..', ...infer ToRest]\n              ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n                ? ToRest extends ['/']\n                  ? Join<['/', ...FromRest, '/']>\n                  : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n                : never\n              : Split<TTo> extends ['.', ...infer ToRest]\n                ? ToRest extends ['/']\n                  ? Join<[TFrom, '/']>\n                  : ResolveRelativePath<TFrom, Join<ToRest>>\n                : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\n// type Test1 = ResolveRelativePath<'/', '/posts'>\n// //   ^?\n// type Test4 = ResolveRelativePath<'/posts/1/comments', '../..'>\n// //   ^?\n// type Test5 = ResolveRelativePath<'/posts/1/comments', '../../..'>\n// //   ^?\n// type Test6 = ResolveRelativePath<'/posts/1/comments', './1'>\n// //   ^?\n// type Test7 = ResolveRelativePath<'/posts/1/comments', './1/2'>\n// //   ^?\n// type Test8 = ResolveRelativePath<'/posts/1/comments', '../edit'>\n// //   ^?\n// type Test9 = ResolveRelativePath<'/posts/1/comments', '1'>\n// //   ^?\n// type Test10 = ResolveRelativePath<'/posts/1/comments', './1'>\n// //   ^?\n// type Test11 = ResolveRelativePath<'/posts/1/comments', './1/2'>\n// //   ^?\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! â˜ï¸'\n\nexport function useLinkProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n  const [isTransitioning, setIsTransitioning] = React.useState(false)\n\n  const {\n    // custom props\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    viewTransition,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  const dest = {\n    ...(options.to && { from: matchPathname }),\n    ...options,\n  }\n\n  let type: 'internal' | 'external' = 'internal'\n\n  try {\n    new URL(`${to}`)\n    type = 'external'\n  } catch {}\n\n  const next = router.buildLocation(dest as any)\n  const preload = userPreload ?? router.options.defaultPreload\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      // Compare path/hash for matches\n      const currentPathSplit = s.location.pathname.split('/')\n      const nextPathSplit = next.pathname.split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact\n        ? exactPathTest(s.location.pathname, next.pathname)\n        : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash\n        ? s.location.hash === next.hash\n        : true\n      const searchTest =\n        activeOptions?.includeSearch ?? true\n          ? deepEqual(s.location.search, next.search, !activeOptions?.exact)\n          : true\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest\n    },\n  })\n\n  if (type === 'external') {\n    return {\n      ...rest,\n      type,\n      href: to,\n      ...(children && { children }),\n      ...(target && { target }),\n      ...(disabled && { disabled }),\n      ...(style && { style }),\n      ...(className && { className }),\n      ...(onClick && { onClick }),\n      ...(onFocus && { onFocus }),\n      ...(onMouseEnter && { onMouseEnter }),\n      ...(onMouseLeave && { onMouseLeave }),\n      ...(onTouchStart && { onTouchStart }),\n    }\n  }\n\n  // The click handler\n  const handleClick = (e: MouseEvent) => {\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      flushSync(() => {\n        setIsTransitioning(true)\n      })\n\n      const unsub = router.subscribe('onResolved', () => {\n        unsub()\n        setIsTransitioning(false)\n      })\n\n      // All is well? Navigate!\n      router.commitLocation({\n        ...next,\n        replace,\n        resetScroll,\n        startTransition,\n        viewTransition,\n      })\n    }\n  }\n\n  const doPreload = () => {\n    router.preloadRoute(dest as any).catch((err) => {\n      console.warn(err)\n      console.warn(preloadWarning)\n    })\n  }\n\n  // The click handler\n  const handleFocus = (e: MouseEvent) => {\n    if (disabled) return\n    if (preload) {\n      doPreload()\n    }\n  }\n\n  const handleTouchStart = handleFocus\n\n  const handleEnter = (e: MouseEvent) => {\n    if (disabled) return\n    const eventTarget = (e.target || {}) as LinkCurrentTargetElement\n\n    if (preload) {\n      if (eventTarget.preloadTimeout) {\n        return\n      }\n\n      eventTarget.preloadTimeout = setTimeout(() => {\n        eventTarget.preloadTimeout = null\n        doPreload()\n      }, preloadDelay)\n    }\n  }\n\n  const handleLeave = (e: MouseEvent) => {\n    if (disabled) return\n    const eventTarget = (e.target || {}) as LinkCurrentTargetElement\n\n    if (eventTarget.preloadTimeout) {\n      clearTimeout(eventTarget.preloadTimeout)\n      eventTarget.preloadTimeout = null\n    }\n  }\n\n  const composeHandlers =\n    (handlers: Array<undefined | ((e: any) => void)>) =>\n    (e: { persist?: () => void; defaultPrevented: boolean }) => {\n      e.persist?.()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {})\n\n  const resolvedClassName = [\n    className,\n    resolvedActiveProps.className,\n    resolvedInactiveProps.className,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  const resolvedStyle = {\n    ...style,\n    ...resolvedActiveProps.style,\n    ...resolvedInactiveProps.style,\n  }\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n        ? router.history.createHref(next.maskedLocation.href)\n        : router.history.createHref(next.href),\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    ...(Object.keys(resolvedStyle).length && { style: resolvedStyle }),\n    ...(resolvedClassName && { className: resolvedClassName }),\n    ...(disabled && {\n      role: 'link',\n      'aria-disabled': true,\n    }),\n    ...(isActive && { 'data-status': 'active', 'aria-current': 'page' }),\n    ...(isTransitioning && { 'data-transitioning': 'transitioning' }),\n  }\n}\n\nexport type UseLinkPropsOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type ActiveLinkOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = LinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n\nexport type LinkProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = string,\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | React.ReactNode\n    | ((state: {\n        isActive: boolean\n        isTransitioning: boolean\n      }) => React.ReactNode)\n}\n\ntype LinkComponentProps<TComp> = React.PropsWithoutRef<\n  TComp extends React.FC<infer TProps> | React.Component<infer TProps>\n    ? TProps\n    : TComp extends keyof JSX.IntrinsicElements\n      ? Omit<React.HTMLProps<TComp>, 'children' | 'preload'>\n      : never\n> &\n  React.RefAttributes<\n    TComp extends\n      | React.FC<{ ref: infer TRef }>\n      | React.Component<{ ref: infer TRef }>\n      ? TRef\n      : TComp extends keyof JSX.IntrinsicElements\n        ? React.ComponentRef<TComp>\n        : never\n  >\n\nexport type LinkComponent<TComp> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  props: LinkProps<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n    LinkComponentProps<TComp>,\n) => React.ReactElement\n\nexport function createLink<const TComp>(Comp: TComp): LinkComponent<TComp> {\n  return React.forwardRef(function CreatedLink(props, ref) {\n    return <Link {...(props as any)} _asChild={Comp} ref={ref} />\n  }) as any\n}\n\nexport const Link: LinkComponent<'a'> = React.forwardRef((props: any, ref) => {\n  const { _asChild, ...rest } = props\n  const { type, ...linkProps } = useLinkProps(rest)\n\n  const children =\n    typeof rest.children === 'function'\n      ? rest.children({\n          isActive: (linkProps as any)['data-status'] === 'active',\n        })\n      : rest.children\n\n  return React.createElement(\n    _asChild ? _asChild : 'a',\n    {\n      ...linkProps,\n      ref,\n    },\n    children,\n  )\n}) as any\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n", "import * as React from 'react'\n\nconst useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nimport { useRouter } from './useRouter'\nimport { functionalUpdate } from './utils'\nimport type { ParsedLocation } from './location'\nimport type { NonNullableUpdater } from './utils'\n\nconst windowKey = 'window'\nconst delimiter = '___'\n\nlet weakScrolledElements = new WeakSet<any>()\n\ntype CacheValue = Record<string, { scrollX: number; scrollY: number }>\ntype CacheState = {\n  cached: CacheValue\n  next: CacheValue\n}\n\ntype Cache = {\n  state: CacheState\n  set: (updater: NonNullableUpdater<CacheState>) => void\n}\n\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage\n\nconst cache: Cache = sessionsStorage\n  ? (() => {\n      const storageKey = 'tsr-scroll-restoration-v2'\n\n      const state: CacheState = JSON.parse(\n        window.sessionStorage.getItem(storageKey) || 'null',\n      ) || { cached: {}, next: {} }\n\n      return {\n        state,\n        set: (updater) => {\n          cache.state = functionalUpdate(updater, cache.state)\n          window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state))\n        },\n      }\n    })()\n  : (undefined as any)\n\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n}\n\nconst defaultGetKey = (location: ParsedLocation) => location.state.key!\n\nexport function useScrollRestoration(options?: ScrollRestorationOptions) {\n  const router = useRouter()\n\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey\n\n    const { history } = window\n    history.scrollRestoration = 'manual'\n\n    const onScroll = (event: Event) => {\n      if (weakScrolledElements.has(event.target)) return\n      weakScrolledElements.add(event.target)\n\n      let elementSelector = ''\n\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey\n      } else {\n        const attrId = (event.target as Element).getAttribute(\n          'data-scroll-restoration-id',\n        )\n\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n        } else {\n          elementSelector = getCssSelector(event.target)\n        }\n      }\n\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN,\n            },\n          },\n        }))\n      }\n    }\n\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true)\n    }\n\n    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation)\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector]!\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0\n            entry.scrollY = window.scrollY || 0\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector)\n            entry.scrollX = element?.scrollLeft || 0\n            entry.scrollY = element?.scrollTop || 0\n          }\n\n          cache.set((c) => {\n            const next = { ...c.next }\n            delete next[elementSelector]\n\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry,\n              },\n            }\n          })\n        }\n      }\n    })\n\n    const unsubOnResolved = router.subscribe('onResolved', (event) => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return\n        }\n\n        router.resetNextScroll = true\n\n        const restoreKey = getKey(event.toLocation)\n        let windowRestored = false\n\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey]!\n          const [key, elementSelector] = cacheKey.split(delimiter)\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true\n              window.scrollTo(entry.scrollX, entry.scrollY)\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector)\n              if (element) {\n                element.scrollLeft = entry.scrollX\n                element.scrollTop = entry.scrollY\n              }\n            }\n          }\n        }\n\n        if (!windowRestored) {\n          window.scrollTo(0, 0)\n        }\n\n        cache.set((c) => ({ ...c, next: {} }))\n        weakScrolledElements = new WeakSet<any>()\n      }\n    })\n\n    return () => {\n      document.removeEventListener('scroll', onScroll)\n      unsubOnBeforeLoad()\n      unsubOnResolved()\n    }\n  }, [options?.getKey, router])\n}\n\nexport function ScrollRestoration(props: ScrollRestorationOptions) {\n  useScrollRestoration(props)\n  return null\n}\n\nexport function useElementScrollRestoration(\n  options: (\n    | {\n        id: string\n        getElement?: () => Element | undefined | null\n      }\n    | {\n        id?: string\n        getElement: () => Element | undefined | null\n      }\n  ) & {\n    getKey?: (location: ParsedLocation) => string\n  },\n) {\n  const router = useRouter()\n  const getKey = options.getKey || defaultGetKey\n\n  let elementSelector = ''\n\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`\n  } else {\n    const element = options.getElement?.()\n    if (!element) {\n      return\n    }\n    elementSelector = getCssSelector(element)\n  }\n\n  const restoreKey = getKey(router.latestLocation)\n  const cacheKey = [restoreKey, elementSelector].join(delimiter)\n  return cache.state.cached[cacheKey]\n}\n\nfunction getCssSelector(el: any): string {\n  const path = []\n  let parent\n  while ((parent = el.parentNode)) {\n    path.unshift(\n      `${el.tagName}:nth-child(${\n        ([].indexOf as any).call(parent.children, el) + 1\n      })`,\n    )\n    el = parent\n  }\n  return `${path.join(' > ')}`.toLowerCase()\n}\n", "import * as React from 'react'\nimport { useRouter } from './useRouter'\nimport type { BlockerFn } from '@tanstack/history'\nimport type { ReactNode } from './route'\n\nexport function useBlocker(\n  blockerFn: BlockerFn,\n  condition: boolean | any = true,\n): void {\n  const { history } = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n    return history.block(blockerFn)\n  })\n}\n\nexport function Block({ blocker, condition, children }: PromptProps) {\n  useBlocker(blocker, condition)\n  return children ?? null\n}\n\nexport type PromptProps = {\n  blocker: BlockerFn\n  condition?: boolean | any\n  children?: ReactNode\n}\n", "import { useMatch } from './Matches'\nimport type { MakeRouteMatch } from './Matches'\nimport type { AnyRoute } from './route'\nimport type { RouteById, RouteIds } from './routeInfo'\nimport type { RegisteredRouter } from './router'\nimport type { StrictOrFrom } from './utils'\n\nexport function useRouteContext<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'],\n  TSelected = TRouteContext,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TRouteContext) => TSelected\n  },\n): TSelected {\n  return useMatch({\n    ...(opts as any),\n    select: (match: MakeRouteMatch<TRouteTree, TFrom>) =>\n      opts.select ? opts.select(match.context) : match.context,\n  })\n}\n"],
  "mappings": "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",
  "names": ["useLayoutEffect", "_a", "Outlet", "options", "lazyFn", "routerContext", "useLayoutEffect", "_a", "_b", "redirect", "notFound", "_c", "match", "_a", "opts", "matchPathname", "useLayoutEffect"]
}
