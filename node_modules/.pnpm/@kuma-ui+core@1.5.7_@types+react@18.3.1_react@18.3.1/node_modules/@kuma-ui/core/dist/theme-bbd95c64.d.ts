import { NestedObject, Pretty, FlattenObject } from './utils/object.js';
import { If, IsNever, _String, Stringify } from './utils/types.js';
import { componentList } from './components/componentList.js';
import { StyledProps, PseudoProps } from '@kuma-ui/system';
import { Tokens } from '@kuma-ui/sheet';

type ThemeTokens<T extends string> = Theme extends Record<T, unknown> ? Theme[T] : never;
type NumberToken = "fontSizes" | "fontWeights" | "lineHeights" | "letterSpacings" | "breakpoints";
type InputThemeTokens = {
    [K in Tokens]?: K extends NumberToken ? NestedObject<string | number> : NestedObject<string>;
};
type ResultThemeTokens<T extends InputThemeTokens> = {
    [K in keyof T]: Pretty<FlattenObject<Pick<T, K>>>;
};
type SystemThemeTokens = {
    [K in Tokens]: If<IsNever<ThemeTokens<K>>, _String, Stringify<keyof ThemeTokens<K>>>;
};

type StyleProps = StyledProps & PseudoProps;
type RawThemeComponent = {
    /**
     * @deprecated use `defaultProps` instead
     */
    baseStyle?: StyleProps;
    variants?: {
        [key: string]: StyleProps;
    };
    defaultProps?: {
        variant?: string;
    } & StyleProps & Record<string, unknown>;
};
type RawThemeComponents = {
    [_ in keyof typeof componentList]?: RawThemeComponent;
};
type RawThemeInput = InputThemeTokens & {
    components?: RawThemeComponents;
};
type ThemeComponent<T> = {
    [K in keyof T]?: K extends "baseStyle" ? StyleProps : K extends "variants" ? {
        [_ in keyof T[K]]: StyleProps;
    } : K extends "defaultProps" ? {
        variant?: T extends RawThemeComponent ? keyof T["variants"] : never;
    } : never;
};
type ThemeInput<T> = RawThemeInput & {
    [K in keyof T]: K extends "components" ? T[K] extends RawThemeComponents ? {
        [K2 in keyof T[K]]?: ThemeComponent<T[K][K2]>;
    } : never : K extends keyof InputThemeTokens ? T[K] extends NestedObject<K extends NumberToken ? string | number : string> | undefined ? T[K] : never : never;
};
type ThemeResult<T> = Pretty<ResultThemeTokens<Omit<T, "components">> & ThemeComponentsResult<T>>;
type ThemeComponentsResult<T> = {
    components: T extends Record<"components", unknown> ? T["components"] : undefined;
};
interface Theme {
}
type ThemeComponents = Theme extends {
    components: unknown;
} ? Theme["components"] : never;
type ThemeSystem = {
    components: If<IsNever<ThemeComponents>, unknown, ThemeComponents>;
} & SystemThemeTokens;
declare function createTheme<const T extends ThemeInput<T>>(theme: T): ThemeResult<T>;

export { InputThemeTokens as I, NumberToken as N, RawThemeInput as R, SystemThemeTokens as S, Theme as T, ThemeSystem as a, ResultThemeTokens as b, createTheme as c, ThemeInput as d };
