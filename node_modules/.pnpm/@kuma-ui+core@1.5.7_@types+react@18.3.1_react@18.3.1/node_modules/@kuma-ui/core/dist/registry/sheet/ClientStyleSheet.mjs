// src/registry/sheet/ClientStyleSheet.ts
import { isProduction } from "../../utils/isProduction.mjs";
var ClientStyleSheet = class {
  name;
  deletedRulePlaceholder;
  speedy;
  tags;
  injected;
  rulesCount;
  constructor(name, speedy = false) {
    this.name = name;
    this.deletedRulePlaceholder = `#${name}-deleted-rule{}`;
    this.speedy = speedy;
    this.tags = [];
    this.injected = false;
    this.rulesCount = 0;
  }
  inject() {
    if (this.injected) {
      throw new Error("ClientStyleSheet: sheet already injected");
    }
    if (this.speedy) {
      this.tags[0] = this.makeStyleTag();
      this.speedy = "insertRule" in this.getLatestSheet();
      if (!this.speedy) {
        if (!isProduction) {
          console.warn(
            "ClientStyleSheet: speedy mode not supported falling back to standard mode."
          );
        }
        this.flush();
      }
    }
    this.injected = true;
  }
  isSpeedy() {
    return this.speedy;
  }
  setSpeedy(bool) {
    if (this.rulesCount === 0) {
      throw new Error(
        "ClientStyleSheet: speedy cannot be when rules have already been inserted"
      );
    }
    this.flush();
    this.speedy = bool;
    this.inject();
  }
  insertRule(rule, index) {
    if (this.speedy) {
      const sheet = this.getLatestSheet();
      if (typeof index !== "number") {
        index = sheet.cssRules.length;
      }
      try {
        sheet.insertRule(rule, index);
      } catch (error) {
        if (!isProduction) {
          console.warn(
            `ClientStyleSheet: illegal rule: 

${rule}

See https://stackoverflow.com/q/20007992 for more info`
          );
        }
        return -1;
      }
      return this.rulesCount++;
    }
    const insertionPoint = index ? this.tags[index] : void 0;
    this.tags = this.tags.concat(this.makeStyleTag(rule, insertionPoint));
    return this.rulesCount++;
  }
  deleteRule(index) {
    if (index < 0) {
      return;
    }
    if (this.speedy) {
      const sheet = this.getLatestSheet();
      sheet.deleteRule(index);
      sheet.insertRule(this.deletedRulePlaceholder, index);
      return;
    }
    const tag = this.tags[index];
    if (!tag) {
      throw new Error(`ClientStyleSheet: rule at index \`${index}\` not found`);
    }
    tag.parentNode?.removeChild(tag);
    delete this.tags[index];
  }
  flush() {
    this.injected = false;
    this.rulesCount = 0;
    this.tags.forEach((tag) => tag && tag.parentNode?.removeChild(tag));
    this.tags = [];
  }
  cssRules() {
    return this.tags.reduce(
      (rules, tag) => {
        if (tag) {
          return rules.concat(
            Array.from(
              this.getSheet(tag).cssRules,
              (rule) => rule.cssText === this.deletedRulePlaceholder ? void 0 : rule
            )
          );
        }
        return rules;
      },
      []
    );
  }
  makeStyleTag(cssString, relativeToTag) {
    const tag = document.createElement("style");
    tag.setAttribute(`data-${this.name}`, "");
    const nonce = document.querySelector('meta[property="csp-nonce"]')?.getAttribute("content");
    if (nonce) {
      tag.setAttribute("nonce", nonce);
    }
    if (cssString) {
      tag.appendChild(document.createTextNode(cssString));
    }
    const head = document.head || document.getElementsByTagName("head")[0];
    if (relativeToTag) {
      head.insertBefore(tag, relativeToTag);
    } else {
      head.appendChild(tag);
    }
    return tag;
  }
  getSheet(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    const sheet = Array.from(document.styleSheets).find(
      (sheet2) => sheet2.ownerNode === tag
    );
    if (sheet) {
      return sheet;
    }
    throw new Error("ClientStyleSheet: styleSheet not found");
  }
  getLatestSheet() {
    const latestTag = this.tags[this.tags.length - 1];
    if (!latestTag) {
      throw new Error("ClientStyleSheet: style tag not found");
    }
    return this.getSheet(latestTag);
  }
};
export {
  ClientStyleSheet
};
