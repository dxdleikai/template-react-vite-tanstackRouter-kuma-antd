"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/collector/expression.ts
var expression_exports = {};
__export(expression_exports, {
  handleJsxExpression: () => handleJsxExpression
});
module.exports = __toCommonJS(expression_exports);
var import_ts_morph = require("ts-morph");
var handleJsxExpression = (node) => {
  if (import_ts_morph.Node.isNumericLiteral(node)) {
    return node.getLiteralValue();
  }
  if (import_ts_morph.Node.isStringLiteral(node)) {
    return node.getLiteralValue().trim();
  }
  if (import_ts_morph.Node.isNoSubstitutionTemplateLiteral(node)) {
    return node.getLiteralValue().trim();
  }
  if (import_ts_morph.Node.isTrueLiteral(node)) {
    return node.getLiteralValue();
  }
  if (import_ts_morph.Node.isFalseLiteral(node)) {
    return node.getLiteralValue();
  }
  if (import_ts_morph.Node.isArrayLiteralExpression(node)) {
    const arrayExpression = node.getElements().map((elm) => {
      return handleJsxExpression(elm);
    });
    return arrayExpression.includes(void 0) ? void 0 : arrayExpression;
  }
  if (import_ts_morph.Node.isBinaryExpression(node)) {
    const leftOperand = handleJsxExpression(node.getLeft());
    const rightOperand = handleJsxExpression(node.getRight());
    const operator = node.getOperatorToken().getKind();
    if (typeof leftOperand === "number" && typeof rightOperand === "number") {
      switch (operator) {
        case import_ts_morph.SyntaxKind.PlusToken:
          return leftOperand + rightOperand;
        case import_ts_morph.SyntaxKind.MinusToken:
          return leftOperand - rightOperand;
        case import_ts_morph.SyntaxKind.AsteriskToken:
          return leftOperand * rightOperand;
        case import_ts_morph.SyntaxKind.SlashToken:
          return leftOperand / rightOperand;
        default:
          return void 0;
      }
    }
    return void 0;
  }
  if (import_ts_morph.Node.isObjectLiteralExpression(node)) {
    return void 0;
  }
  if (import_ts_morph.Node.isCallExpression(node)) {
    return void 0;
  }
  return void 0;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handleJsxExpression
});
