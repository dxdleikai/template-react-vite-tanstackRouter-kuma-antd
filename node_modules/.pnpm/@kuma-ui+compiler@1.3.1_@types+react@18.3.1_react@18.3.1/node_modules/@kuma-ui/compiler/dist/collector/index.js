"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/collector/index.ts
var collector_exports = {};
__export(collector_exports, {
  collectPropsFromJsx: () => collectPropsFromJsx
});
module.exports = __toCommonJS(collector_exports);

// src/collector/collect.ts
var import_ts_morph4 = require("ts-morph");

// src/collector/decode.ts
var import_ts_morph = require("ts-morph");
var decode = (node) => {
  if (import_ts_morph.Node.isAsExpression(node)) {
    return decode(node.getExpression());
  }
  if (import_ts_morph.Node.isParenthesizedExpression(node)) {
    return decode(node.getExpression());
  }
  if (import_ts_morph.Node.isNonNullExpression(node)) {
    return decode(node.getExpression());
  }
  if (import_ts_morph.Node.isTypeAssertion(node)) {
    return decode(node.getExpression());
  }
  return node;
};

// src/collector/expression.ts
var import_ts_morph2 = require("ts-morph");
var handleJsxExpression = (node) => {
  if (import_ts_morph2.Node.isNumericLiteral(node)) {
    return node.getLiteralValue();
  }
  if (import_ts_morph2.Node.isStringLiteral(node)) {
    return node.getLiteralValue().trim();
  }
  if (import_ts_morph2.Node.isNoSubstitutionTemplateLiteral(node)) {
    return node.getLiteralValue().trim();
  }
  if (import_ts_morph2.Node.isTrueLiteral(node)) {
    return node.getLiteralValue();
  }
  if (import_ts_morph2.Node.isFalseLiteral(node)) {
    return node.getLiteralValue();
  }
  if (import_ts_morph2.Node.isArrayLiteralExpression(node)) {
    const arrayExpression = node.getElements().map((elm) => {
      return handleJsxExpression(elm);
    });
    return arrayExpression.includes(void 0) ? void 0 : arrayExpression;
  }
  if (import_ts_morph2.Node.isBinaryExpression(node)) {
    const leftOperand = handleJsxExpression(node.getLeft());
    const rightOperand = handleJsxExpression(node.getRight());
    const operator = node.getOperatorToken().getKind();
    if (typeof leftOperand === "number" && typeof rightOperand === "number") {
      switch (operator) {
        case import_ts_morph2.SyntaxKind.PlusToken:
          return leftOperand + rightOperand;
        case import_ts_morph2.SyntaxKind.MinusToken:
          return leftOperand - rightOperand;
        case import_ts_morph2.SyntaxKind.AsteriskToken:
          return leftOperand * rightOperand;
        case import_ts_morph2.SyntaxKind.SlashToken:
          return leftOperand / rightOperand;
        default:
          return void 0;
      }
    }
    return void 0;
  }
  if (import_ts_morph2.Node.isObjectLiteralExpression(node)) {
    return void 0;
  }
  if (import_ts_morph2.Node.isCallExpression(node)) {
    return void 0;
  }
  return void 0;
};

// src/collector/pseudo.ts
var import_ts_morph3 = require("ts-morph");
var extractPseudoAttribute = (jsxAttribute) => {
  const initializer = jsxAttribute.getInitializer();
  if (import_ts_morph3.Node.isJsxExpression(initializer)) {
    const expression = initializer.getExpression();
    if (!expression)
      return;
    const decodedNode = decode(expression);
    return handlePseudoJsxExpression(decodedNode);
  }
  return void 0;
};
var handlePseudoJsxExpression = (node) => {
  if (import_ts_morph3.Node.isObjectLiteralExpression(node)) {
    const objProps = {};
    for (const prop of node.getProperties()) {
      if (import_ts_morph3.Node.isPropertyAssignment(prop)) {
        const initializer = prop.getInitializer();
        if (initializer) {
          const decodedNode = decode(initializer);
          const propName = prop.getName();
          objProps[propName] = handleJsxExpression(decodedNode);
        }
      }
    }
    return Object.values(objProps).includes(void 0) ? void 0 : objProps;
  }
  return handleJsxExpression(node);
};

// src/collector/collect.ts
var collectPropsFromJsx = (node) => {
  const jsxAttributes = node.getAttributes();
  const extracted = {};
  jsxAttributes.forEach((jsxAttribute) => {
    if (import_ts_morph4.Node.isJsxAttribute(jsxAttribute)) {
      const propName = jsxAttribute.getNameNode().getText();
      let propValue;
      if (propName.trim().startsWith("_")) {
        propValue = extractPseudoAttribute(jsxAttribute);
      } else {
        propValue = extractAttribute(jsxAttribute);
      }
      if (propValue == void 0)
        return;
      extracted[propName] = propValue;
    }
  });
  return extracted;
};
var extractAttribute = (jsxAttribute) => {
  const initializer = jsxAttribute.getInitializer();
  if (import_ts_morph4.Node.isStringLiteral(initializer)) {
    const value = initializer.getLiteralText();
    return value;
  }
  if (import_ts_morph4.Node.isJsxExpression(initializer)) {
    const expression = initializer.getExpression();
    if (!expression)
      return;
    const decodedNode = decode(expression);
    return handleJsxExpression(decodedNode);
  }
  if (initializer === void 0) {
    return true;
  }
  return void 0;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  collectPropsFromJsx
});
