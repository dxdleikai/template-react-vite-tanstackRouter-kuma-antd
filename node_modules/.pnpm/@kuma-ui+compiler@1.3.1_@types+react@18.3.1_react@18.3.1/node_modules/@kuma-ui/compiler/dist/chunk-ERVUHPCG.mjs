import {
  extractProps
} from "./chunk-EHUF2A4S.mjs";
import {
  optimize
} from "./chunk-2ACMC6EM.mjs";
import {
  processTaggedTemplateExpression
} from "./chunk-LJ76POXC.mjs";
import {
  collectPropsFromJsx
} from "./chunk-HIVZARW3.mjs";

// src/compile.ts
import {
  Project,
  Node,
  SyntaxKind
} from "ts-morph";
import { componentList } from "@kuma-ui/core/components/componentList";
var project = new Project({});
var compile = (code, id, bindings) => {
  const css = [];
  const source = project.createSourceFile(id, code, { overwrite: true });
  source.forEachDescendant((node) => {
    if (node.getKind() === SyntaxKind.JsxElement || node.getKind() === SyntaxKind.JsxSelfClosingElement) {
      let openingElement;
      if (node.getKind() === SyntaxKind.JsxElement) {
        const jsxElement = node.asKindOrThrow(SyntaxKind.JsxElement);
        openingElement = jsxElement.getOpeningElement();
      } else {
        openingElement = node.asKindOrThrow(SyntaxKind.JsxSelfClosingElement);
      }
      const jsxTagName = openingElement.getTagNameNode().getText();
      const originalComponentName = Object.keys(bindings).find(
        (key) => bindings[key] === jsxTagName && Object.values(componentList).some((c) => c === key)
      );
      if (!originalComponentName)
        return;
      const componentName = originalComponentName;
      const extractedPropsMap = collectPropsFromJsx(openingElement);
      const result = extractProps(
        componentName,
        openingElement,
        extractedPropsMap
      );
      if (result)
        css.push(result.css);
      optimize(
        componentName,
        openingElement,
        extractedPropsMap["as"]
      );
    }
    if (Node.isTaggedTemplateExpression(node)) {
      processTaggedTemplateExpression(node, bindings);
    }
  });
  return { code: source.getFullText(), id, css: css.join(" ") };
};

export {
  compile
};
