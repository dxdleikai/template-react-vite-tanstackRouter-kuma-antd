// src/collector/expression.ts
import { Node, SyntaxKind } from "ts-morph";
var handleJsxExpression = (node) => {
  if (Node.isNumericLiteral(node)) {
    return node.getLiteralValue();
  }
  if (Node.isStringLiteral(node)) {
    return node.getLiteralValue().trim();
  }
  if (Node.isNoSubstitutionTemplateLiteral(node)) {
    return node.getLiteralValue().trim();
  }
  if (Node.isTrueLiteral(node)) {
    return node.getLiteralValue();
  }
  if (Node.isFalseLiteral(node)) {
    return node.getLiteralValue();
  }
  if (Node.isArrayLiteralExpression(node)) {
    const arrayExpression = node.getElements().map((elm) => {
      return handleJsxExpression(elm);
    });
    return arrayExpression.includes(void 0) ? void 0 : arrayExpression;
  }
  if (Node.isBinaryExpression(node)) {
    const leftOperand = handleJsxExpression(node.getLeft());
    const rightOperand = handleJsxExpression(node.getRight());
    const operator = node.getOperatorToken().getKind();
    if (typeof leftOperand === "number" && typeof rightOperand === "number") {
      switch (operator) {
        case SyntaxKind.PlusToken:
          return leftOperand + rightOperand;
        case SyntaxKind.MinusToken:
          return leftOperand - rightOperand;
        case SyntaxKind.AsteriskToken:
          return leftOperand * rightOperand;
        case SyntaxKind.SlashToken:
          return leftOperand / rightOperand;
        default:
          return void 0;
      }
    }
    return void 0;
  }
  if (Node.isObjectLiteralExpression(node)) {
    return void 0;
  }
  if (Node.isCallExpression(node)) {
    return void 0;
  }
  return void 0;
};

export {
  handleJsxExpression
};
