import {
  consumeStyleProps
} from "./chunk-CMEWWC2X.mjs";
import {
  isStyledProp
} from "./chunk-UKLKEGNU.mjs";
import {
  isPseudoProps,
  normalizePseudo
} from "./chunk-QKDAV5R5.mjs";

// src/generator.ts
import { generateHash, theme } from "@kuma-ui/sheet";
var StyleGenerator = class {
  style;
  className;
  constructor(props, isDynamic = false) {
    if (!props || Object.keys(props).length === 0) {
      this.className = "";
      return;
    }
    const styledProps = {};
    const pseudoProps = {};
    const findThemeStyle = (value) => {
      const userTheme = theme.getUserTheme();
      const propKey = value.split(".")[0];
      if (userTheme[propKey] === void 0)
        return void 0;
      for (const key in userTheme[propKey]) {
        if (value === key) {
          return userTheme[propKey][key];
        }
      }
      return void 0;
    };
    const isThemeStyle = (propValue) => {
      return typeof propValue === "string" && /[a-zA-Z]+\.[a-zA-Z0-9]+/.test(propValue) && !/^\w+\(.*\)$/.test(propValue);
    };
    const convertStyle = (name, value) => {
      if (Array.isArray(value)) {
        return value.map((v) => {
          if (isThemeStyle(v)) {
            const customStyle = findThemeStyle(v);
            if (customStyle !== void 0) {
              return customStyle;
            }
          }
          return v;
        });
      } else if (isThemeStyle(value)) {
        const customStyle = findThemeStyle(value);
        if (customStyle !== void 0) {
          return customStyle;
        }
      } else if (isStyledProp(name)) {
        return value;
      }
      return value;
    };
    for (const [propName, propValue] of Object.entries(props)) {
      if (isPseudoProps(propName)) {
        pseudoProps[propName] = propValue;
        for (const [name, value] of Object.entries(propValue)) {
          pseudoProps[propName] = {
            ...pseudoProps[propName],
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- FIXME
            [name]: convertStyle(name, value)
          };
        }
      } else {
        styledProps[propName] = convertStyle(propName, propValue);
      }
    }
    const convertedPseudoProps = Object.keys(pseudoProps).length ? Object.entries(pseudoProps).map(([pseudoKey, pseudoValue]) => {
      const pseudoStyle = all(pseudoValue);
      return {
        key: normalizePseudo(pseudoKey),
        base: pseudoStyle.base,
        responsive: pseudoStyle.media
      };
    }) : [];
    this.style = {
      base: all(styledProps).base,
      responsive: all(styledProps).media,
      pseudo: convertedPseudoProps
    };
    this.className = StyleGenerator.getClassNamePrefix(isDynamic) + generateHash(JSON.stringify(this.style));
  }
  static getClassNamePrefix(isDynamic = false) {
    const isProduction = process.env.NODE_ENV === "production";
    if (isProduction)
      return "kuma-";
    return isDynamic ? "\u{1F984}-" : "\u{1F43B}-";
  }
  getClassName() {
    return this.className;
  }
  getCSS() {
    if (!this.style) {
      return "";
    }
    let css = `.${this.className} { ${this.style.base} }`;
    for (const [breakpoint, cssValue] of Object.entries(
      this.style.responsive
    )) {
      css += `@media (min-width: ${breakpoint}) { .${this.className} { ${cssValue} } }`;
    }
    for (const pseudo of this.style.pseudo) {
      css += `.${this.className}${pseudo.key} { ${pseudo.base} }`;
      for (const [breakpoint, cssValue] of Object.entries(pseudo.responsive)) {
        css += `@media (min-width: ${breakpoint}) { .${this.className}${pseudo.key} { ${cssValue} } }`;
      }
    }
    return css;
  }
  getStyle() {
    return { css: this.getCSS(), className: this.getClassName() };
  }
};

// src/index.ts
var all = consumeStyleProps;

export {
  all,
  StyleGenerator
};
