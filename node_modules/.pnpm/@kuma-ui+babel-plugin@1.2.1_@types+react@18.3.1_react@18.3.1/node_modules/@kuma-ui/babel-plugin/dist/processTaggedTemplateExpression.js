"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/processTaggedTemplateExpression.ts
var processTaggedTemplateExpression_exports = {};
__export(processTaggedTemplateExpression_exports, {
  processTaggedTemplateExpression: () => processTaggedTemplateExpression
});
module.exports = __toCommonJS(processTaggedTemplateExpression_exports);
var import_sheet = require("@kuma-ui/sheet");
var import_core = require("@babel/core");
var processTaggedTemplateExpression = (nodePath, template, importedStyleFunctions) => {
  nodePath.traverse({
    TaggedTemplateExpression(path) {
      const { node } = path;
      if (import_core.types.isIdentifier(node.tag) && importedStyleFunctions["css"] === node.tag.name) {
        const cssString2 = node.quasi.quasis.map((quasi) => quasi.value.raw).join("");
        const className2 = cssString2 ? import_sheet.sheet.parseCSS(cssString2) : void 0;
        if (className2)
          path.replaceWith(import_core.types.stringLiteral(className2));
        return;
      }
      const hasStyled = Object.keys(importedStyleFunctions).some(
        (key) => import_core.types.isCallExpression(node.tag) && import_core.types.isIdentifier(node.tag.callee) && importedStyleFunctions[key] === node.tag.callee.name
      );
      if (!(import_core.types.isCallExpression(node.tag) && hasStyled))
        return;
      const componentArg = node.tag.arguments[0];
      const cssStrings = node.quasi.quasis.map((quasi) => quasi.value.raw);
      const cssString = cssStrings.map((str) => str.replace(/\s+/g, " ").trim()).join("");
      const className = !!cssString ? import_sheet.sheet.parseCSS(cssString) : void 0;
      const component = import_core.types.isStringLiteral(componentArg) ? componentArg.value : "div";
      const createElementAst = template.expression.ast(
        `
        (props) => {
            const existingClassName = props.className || "";
            const newClassName = "${className || ""}";
            const combinedClassName = [existingClassName, newClassName].filter(Boolean).join(" ");
            return (
              <${importedStyleFunctions["Box"]} as="${component}" {...props} className={combinedClassName} IS_KUMA_DEFAULT />
            );
        }`,
        {
          plugins: ["jsx"]
        }
      );
      path.replaceWith(createElementAst);
    }
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  processTaggedTemplateExpression
});
