// src/processTaggedTemplateExpression.ts
import { sheet } from "@kuma-ui/sheet";
import { types as t } from "@babel/core";
var processTaggedTemplateExpression = (nodePath, template, importedStyleFunctions) => {
  nodePath.traverse({
    TaggedTemplateExpression(path) {
      const { node } = path;
      if (t.isIdentifier(node.tag) && importedStyleFunctions["css"] === node.tag.name) {
        const cssString2 = node.quasi.quasis.map((quasi) => quasi.value.raw).join("");
        const className2 = cssString2 ? sheet.parseCSS(cssString2) : void 0;
        if (className2)
          path.replaceWith(t.stringLiteral(className2));
        return;
      }
      const hasStyled = Object.keys(importedStyleFunctions).some(
        (key) => t.isCallExpression(node.tag) && t.isIdentifier(node.tag.callee) && importedStyleFunctions[key] === node.tag.callee.name
      );
      if (!(t.isCallExpression(node.tag) && hasStyled))
        return;
      const componentArg = node.tag.arguments[0];
      const cssStrings = node.quasi.quasis.map((quasi) => quasi.value.raw);
      const cssString = cssStrings.map((str) => str.replace(/\s+/g, " ").trim()).join("");
      const className = !!cssString ? sheet.parseCSS(cssString) : void 0;
      const component = t.isStringLiteral(componentArg) ? componentArg.value : "div";
      const createElementAst = template.expression.ast(
        `
        (props) => {
            const existingClassName = props.className || "";
            const newClassName = "${className || ""}";
            const combinedClassName = [existingClassName, newClassName].filter(Boolean).join(" ");
            return (
              <${importedStyleFunctions["Box"]} as="${component}" {...props} className={combinedClassName} IS_KUMA_DEFAULT />
            );
        }`,
        {
          plugins: ["jsx"]
        }
      );
      path.replaceWith(createElementAst);
    }
  });
};
export {
  processTaggedTemplateExpression
};
