"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/processCSS.ts
var processCSS_exports = {};
__export(processCSS_exports, {
  processCSS: () => processCSS
});
module.exports = __toCommonJS(processCSS_exports);

// src/extractStyleProps/fromObject.ts
var import_core = require("@babel/core");
var import_system = require("@kuma-ui/system");
function extractStylePropsFromObjectExpression(path, objectExpression) {
  const styledProps = {};
  const pseudoProps = {};
  const filteredProperties = objectExpression.properties?.filter((prop) => {
    if (import_core.types.isObjectProperty(prop) && import_core.types.isIdentifier(prop.key) && (0, import_system.isStyledProp)(prop.key.name)) {
      if (import_core.types.isStringLiteral(prop.value) || import_core.types.isNumericLiteral(prop.value)) {
        styledProps[prop.key.name] = prop.value.value;
      } else if (import_core.types.isIdentifier(prop.value)) {
        const binding = path.scope.getBinding(prop.value.name);
        if (binding && ["const", "let", "var"].includes(binding.kind)) {
          const declaration = binding.path.node;
          if (import_core.types.isVariableDeclarator(declaration)) {
            const init = declaration.init;
            if (import_core.types.isStringLiteral(init) || import_core.types.isNumericLiteral(init)) {
              styledProps[prop.key.name] = init.value;
            }
          }
        }
      } else if (import_core.types.isMemberExpression(prop.value)) {
        const getPropertyPath = (expr) => {
          const path2 = [];
          let currentExpr = expr;
          while (import_core.types.isMemberExpression(currentExpr)) {
            if (import_core.types.isIdentifier(currentExpr.property)) {
              path2.unshift(currentExpr.property.name);
            }
            currentExpr = currentExpr.object;
          }
          if (import_core.types.isIdentifier(currentExpr)) {
            path2.unshift(currentExpr.name);
          }
          return path2;
        };
        const dfs = (objBinding2, propertyPath2) => {
          if (!objBinding2)
            return null;
          const objDeclaration = "path" in objBinding2 ? objBinding2.path.node : objBinding2;
          if (!import_core.types.isVariableDeclarator(objDeclaration) && !import_core.types.isObjectExpression(objDeclaration)) {
            return null;
          }
          const objExpression = "init" in objDeclaration ? objDeclaration.init : objDeclaration;
          if (!import_core.types.isObjectExpression(objExpression))
            return null;
          const [nextProperty, ...remainingPath] = propertyPath2;
          for (const prop2 of objExpression.properties) {
            if (import_core.types.isObjectProperty(prop2) && import_core.types.isIdentifier(prop2.key)) {
              if (prop2.key.name === nextProperty) {
                if (remainingPath.length === 0 && import_core.types.isExpression(prop2.value)) {
                  return prop2.value;
                } else {
                  if (import_core.types.isObjectExpression(prop2.value)) {
                    return dfs(prop2.value, remainingPath);
                  } else if (import_core.types.isIdentifier(prop2.value)) {
                    const nextObjBinding = path.scope.getBinding(
                      prop2.value.name
                    );
                    return dfs(nextObjBinding, remainingPath);
                  } else {
                    return null;
                  }
                }
              }
            }
          }
          return null;
        };
        const propertyPath = getPropertyPath(prop.value);
        if (propertyPath.length === 0)
          return;
        const objBinding = path.scope.getBinding(propertyPath[0]);
        const target = dfs(objBinding, propertyPath.slice(1));
        if (target && (import_core.types.isStringLiteral(target) || import_core.types.isNumericLiteral(target))) {
          styledProps[prop.key.name] = target.value;
        }
      } else if (import_core.types.isArrayExpression(prop.value)) {
        styledProps[prop.key.name] = prop.value.elements.map((e) => {
          if (e?.type === "NumericLiteral" || e?.type === "StringLiteral") {
            return e.value;
          }
        }).filter(Boolean);
      }
      return false;
    } else if (import_core.types.isObjectProperty(prop) && import_core.types.isIdentifier(prop.key) && import_core.types.isObjectExpression(prop.value) && (0, import_system.isPseudoProps)(prop.key.name)) {
      Object.assign(pseudoProps, {
        ...pseudoProps,
        [prop.key.name]: extractStylePropsFromObjectExpression(path, prop.value).styledProps
      });
      return false;
    } else if (import_core.types.isObjectProperty(prop) && prop.key.type === "StringLiteral" && prop.key.value === "data-kuma-ui") {
      return false;
    }
    return true;
  }) || [];
  return { filteredProperties, styledProps, pseudoProps };
}

// src/processCSS.ts
var import_sheet = require("@kuma-ui/sheet");
var import_system2 = require("@kuma-ui/system");
function processCSS(nodePath, t2, template, importedStyleFunctions) {
  nodePath.traverse({
    CallExpression(path) {
      const { node } = path;
      const isCSS = t2.isIdentifier(node.callee) && node.callee.name === importedStyleFunctions["css"];
      if (!isCSS)
        return;
      if (!(node.arguments.length === 1 && t2.isObjectExpression(node.arguments[0]))) {
        path.replaceWith(t2.stringLiteral(""));
        return;
      }
      const styleObject = extractStylePropsFromObjectExpression(
        path,
        node.arguments[0]
      );
      const convertedPseudoProps = Object.entries(
        styleObject.pseudoProps
      ).map(([pseudoKey, pseudoValue]) => {
        const pseudoStyle = (0, import_system2.all)(pseudoValue);
        return {
          key: (0, import_system2.normalizePseudo)(pseudoKey),
          base: pseudoStyle.base,
          responsive: pseudoStyle.media
        };
      });
      const style = {
        base: (0, import_system2.all)(styleObject.styledProps).base,
        responsive: (0, import_system2.all)(styleObject.styledProps).media,
        pseudo: convertedPseudoProps
      };
      const className = import_sheet.sheet.addRule(style);
      path.replaceWith(t2.stringLiteral(className));
      return;
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  processCSS
});
