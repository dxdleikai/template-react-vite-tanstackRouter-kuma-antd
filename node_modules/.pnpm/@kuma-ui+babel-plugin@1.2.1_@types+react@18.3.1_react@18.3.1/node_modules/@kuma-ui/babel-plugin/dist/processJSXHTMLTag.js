"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/processJSXHTMLTag.ts
var processJSXHTMLTag_exports = {};
__export(processJSXHTMLTag_exports, {
  processJSXHTMLTag: () => processJSXHTMLTag
});
module.exports = __toCommonJS(processJSXHTMLTag_exports);
var import_core4 = require("@babel/core");

// src/extractStyleProps/index.ts
var import_core3 = require("@babel/core");

// src/extractStyleProps/fromJSX.ts
var import_core2 = require("@babel/core");
var import_system2 = require("@kuma-ui/system");

// src/extractStyleProps/fromObject.ts
var import_core = require("@babel/core");
var import_system = require("@kuma-ui/system");
function extractStylePropsFromObjectExpression(path, objectExpression) {
  const styledProps = {};
  const pseudoProps = {};
  const filteredProperties = objectExpression.properties?.filter((prop) => {
    if (import_core.types.isObjectProperty(prop) && import_core.types.isIdentifier(prop.key) && (0, import_system.isStyledProp)(prop.key.name)) {
      if (import_core.types.isStringLiteral(prop.value) || import_core.types.isNumericLiteral(prop.value)) {
        styledProps[prop.key.name] = prop.value.value;
      } else if (import_core.types.isIdentifier(prop.value)) {
        const binding = path.scope.getBinding(prop.value.name);
        if (binding && ["const", "let", "var"].includes(binding.kind)) {
          const declaration = binding.path.node;
          if (import_core.types.isVariableDeclarator(declaration)) {
            const init = declaration.init;
            if (import_core.types.isStringLiteral(init) || import_core.types.isNumericLiteral(init)) {
              styledProps[prop.key.name] = init.value;
            }
          }
        }
      } else if (import_core.types.isMemberExpression(prop.value)) {
        const getPropertyPath = (expr) => {
          const path2 = [];
          let currentExpr = expr;
          while (import_core.types.isMemberExpression(currentExpr)) {
            if (import_core.types.isIdentifier(currentExpr.property)) {
              path2.unshift(currentExpr.property.name);
            }
            currentExpr = currentExpr.object;
          }
          if (import_core.types.isIdentifier(currentExpr)) {
            path2.unshift(currentExpr.name);
          }
          return path2;
        };
        const dfs = (objBinding2, propertyPath2) => {
          if (!objBinding2)
            return null;
          const objDeclaration = "path" in objBinding2 ? objBinding2.path.node : objBinding2;
          if (!import_core.types.isVariableDeclarator(objDeclaration) && !import_core.types.isObjectExpression(objDeclaration)) {
            return null;
          }
          const objExpression = "init" in objDeclaration ? objDeclaration.init : objDeclaration;
          if (!import_core.types.isObjectExpression(objExpression))
            return null;
          const [nextProperty, ...remainingPath] = propertyPath2;
          for (const prop2 of objExpression.properties) {
            if (import_core.types.isObjectProperty(prop2) && import_core.types.isIdentifier(prop2.key)) {
              if (prop2.key.name === nextProperty) {
                if (remainingPath.length === 0 && import_core.types.isExpression(prop2.value)) {
                  return prop2.value;
                } else {
                  if (import_core.types.isObjectExpression(prop2.value)) {
                    return dfs(prop2.value, remainingPath);
                  } else if (import_core.types.isIdentifier(prop2.value)) {
                    const nextObjBinding = path.scope.getBinding(
                      prop2.value.name
                    );
                    return dfs(nextObjBinding, remainingPath);
                  } else {
                    return null;
                  }
                }
              }
            }
          }
          return null;
        };
        const propertyPath = getPropertyPath(prop.value);
        if (propertyPath.length === 0)
          return;
        const objBinding = path.scope.getBinding(propertyPath[0]);
        const target = dfs(objBinding, propertyPath.slice(1));
        if (target && (import_core.types.isStringLiteral(target) || import_core.types.isNumericLiteral(target))) {
          styledProps[prop.key.name] = target.value;
        }
      } else if (import_core.types.isArrayExpression(prop.value)) {
        styledProps[prop.key.name] = prop.value.elements.map((e) => {
          if (e?.type === "NumericLiteral" || e?.type === "StringLiteral") {
            return e.value;
          }
        }).filter(Boolean);
      }
      return false;
    } else if (import_core.types.isObjectProperty(prop) && import_core.types.isIdentifier(prop.key) && import_core.types.isObjectExpression(prop.value) && (0, import_system.isPseudoProps)(prop.key.name)) {
      Object.assign(pseudoProps, {
        ...pseudoProps,
        [prop.key.name]: extractStylePropsFromObjectExpression(path, prop.value).styledProps
      });
      return false;
    } else if (import_core.types.isObjectProperty(prop) && prop.key.type === "StringLiteral" && prop.key.value === "data-kuma-ui") {
      return false;
    }
    return true;
  }) || [];
  return { filteredProperties, styledProps, pseudoProps };
}

// src/extractStyleProps/fromJSX.ts
function extractStylePropsFromJSX(path, openingElement) {
  const styledProps = {};
  const pseudoProps = {};
  const filteredAttributes = openingElement.attributes.filter((attr) => {
    if (import_core2.types.isJSXAttribute(attr) && import_core2.types.isJSXIdentifier(attr.name) && (0, import_system2.isStyledProp)(attr.name.name)) {
      if (import_core2.types.isStringLiteral(attr.value)) {
        styledProps[attr.name.name] = attr.value.value;
      } else if (import_core2.types.isJSXExpressionContainer(attr.value)) {
        const { expression } = attr.value;
        if (import_core2.types.isStringLiteral(expression) || import_core2.types.isNumericLiteral(expression)) {
          styledProps[attr.name.name] = expression.value;
        } else if (import_core2.types.isIdentifier(expression)) {
          const binding = path.scope.getBinding(expression.name);
          if (binding && ["const", "let", "var"].includes(binding.kind)) {
            const declaration = binding.path.node;
            if (import_core2.types.isVariableDeclarator(declaration)) {
              const init = declaration.init;
              if (import_core2.types.isStringLiteral(init) || import_core2.types.isNumericLiteral(init)) {
                styledProps[attr.name.name] = init.value;
              }
            }
          }
        } else if (import_core2.types.isMemberExpression(expression)) {
          const getPropertyPath = (expr) => {
            const path2 = [];
            let currentExpr = expr;
            while (import_core2.types.isMemberExpression(currentExpr)) {
              if (import_core2.types.isIdentifier(currentExpr.property)) {
                path2.unshift(currentExpr.property.name);
              }
              currentExpr = currentExpr.object;
            }
            if (import_core2.types.isIdentifier(currentExpr)) {
              path2.unshift(currentExpr.name);
            }
            return path2;
          };
          const dfs = (objBinding2, propertyPath2) => {
            if (!objBinding2)
              return null;
            const objDeclaration = "path" in objBinding2 ? objBinding2.path.node : objBinding2;
            if (!import_core2.types.isVariableDeclarator(objDeclaration) && !import_core2.types.isObjectExpression(objDeclaration)) {
              return null;
            }
            const objExpression = "init" in objDeclaration ? objDeclaration.init : objDeclaration;
            if (!import_core2.types.isObjectExpression(objExpression))
              return null;
            const [nextProperty, ...remainingPath] = propertyPath2;
            for (const prop of objExpression.properties) {
              if (import_core2.types.isObjectProperty(prop) && import_core2.types.isIdentifier(prop.key)) {
                if (prop.key.name === nextProperty) {
                  if (remainingPath.length === 0 && import_core2.types.isExpression(prop.value)) {
                    return prop.value;
                  } else {
                    if (import_core2.types.isObjectExpression(prop.value)) {
                      return dfs(prop.value, remainingPath);
                    } else if (import_core2.types.isIdentifier(prop.value)) {
                      const nextObjBinding = path.scope.getBinding(
                        prop.value.name
                      );
                      return dfs(nextObjBinding, remainingPath);
                    } else {
                      return null;
                    }
                  }
                }
              }
            }
            return null;
          };
          const propertyPath = getPropertyPath(expression);
          if (propertyPath.length === 0)
            return;
          const objBinding = path.scope.getBinding(propertyPath[0]);
          const target = dfs(objBinding, propertyPath.slice(1));
          if (target && (import_core2.types.isStringLiteral(target) || import_core2.types.isNumericLiteral(target))) {
            styledProps[attr.name.name] = target.value;
          }
        } else if (import_core2.types.isArrayExpression(expression)) {
          styledProps[attr.name.name] = expression.elements.map((e) => {
            if (e?.type === "NumericLiteral" || e?.type === "StringLiteral") {
              return e.value;
            }
          }).filter(Boolean);
        }
      }
      return false;
    } else if (import_core2.types.isJSXAttribute(attr) && import_core2.types.isJSXIdentifier(attr.name) && import_core2.types.isJSXExpressionContainer(attr.value) && import_core2.types.isObjectExpression(attr.value.expression) && (0, import_system2.isPseudoProps)(attr.name.name)) {
      Object.assign(pseudoProps, {
        ...pseudoProps,
        [attr.name.name]: extractStylePropsFromObjectExpression(
          path,
          attr.value.expression
        ).styledProps
      });
      return false;
    } else if (import_core2.types.isJSXAttribute(attr) && import_core2.types.isJSXIdentifier(attr.name) && attr.name.name === "data-kuma-ui") {
      return false;
    }
    return true;
  }) || [];
  return { filteredAttributes, styledProps, pseudoProps };
}

// src/extractStyleProps/index.ts
function extractStyleProps(path) {
  if (import_core3.types.isJSXOpeningElement(path.node)) {
    return extractStylePropsFromJSX(
      path,
      path.node
    );
  } else {
    return extractStylePropsFromObjectExpression(
      path,
      path.node
    );
  }
}

// src/processJSXHTMLTag.ts
var import_sheet = require("@kuma-ui/sheet");
var import_system3 = require("@kuma-ui/system");
var import_system4 = require("@kuma-ui/system");
var processJSXHTMLTag = (path) => {
  const { filteredAttributes, styledProps, pseudoProps } = extractStyleProps(path);
  path.node.attributes = filteredAttributes;
  if (Object.keys(styledProps).length > 0) {
    const convertedPseudoProps = Object.entries(
      pseudoProps
    ).map(([pseudoKey, pseudoValue]) => {
      const pseudoStyle = (0, import_system3.all)(pseudoValue);
      return {
        key: (0, import_system4.normalizePseudo)(pseudoKey),
        base: pseudoStyle.base,
        responsive: pseudoStyle.media
      };
    });
    const style = {
      base: (0, import_system3.all)(styledProps).base,
      responsive: (0, import_system3.all)(styledProps).media,
      pseudo: convertedPseudoProps
    };
    const generatedClassName = import_sheet.sheet.addRule(style);
    const generatedClassNameAttr = import_core4.types.stringLiteral(generatedClassName);
    const classNameAttrs = [generatedClassNameAttr];
    const existsClassNameAttr = path.node.attributes.find(
      (attr) => import_core4.types.isJSXAttribute(attr) && import_core4.types.isJSXIdentifier(attr.name, { name: "className" })
    );
    if (existsClassNameAttr) {
      if (import_core4.types.isStringLiteral(existsClassNameAttr.value)) {
        classNameAttrs.push(existsClassNameAttr.value);
      }
      if (import_core4.types.isJSXExpressionContainer(existsClassNameAttr.value) && import_core4.types.isExpression(existsClassNameAttr.value.expression)) {
        classNameAttrs.push(existsClassNameAttr.value.expression);
      }
    }
    if (existsClassNameAttr) {
      existsClassNameAttr.value = import_core4.types.jSXExpressionContainer(
        import_core4.types.callExpression(
          import_core4.types.memberExpression(
            import_core4.types.arrayExpression(classNameAttrs),
            import_core4.types.identifier("join")
          ),
          [import_core4.types.stringLiteral(" ")]
        )
      );
    } else {
      path.node.attributes.push(
        import_core4.types.jsxAttribute(import_core4.types.jsxIdentifier("className"), generatedClassNameAttr)
      );
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  processJSXHTMLTag
});
