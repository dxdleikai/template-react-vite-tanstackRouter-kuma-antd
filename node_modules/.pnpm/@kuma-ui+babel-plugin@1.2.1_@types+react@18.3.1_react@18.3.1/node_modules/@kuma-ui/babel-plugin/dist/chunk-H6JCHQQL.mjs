// src/extractStyleProps/fromObject.ts
import { types as t } from "@babel/core";
import { isStyledProp, isPseudoProps } from "@kuma-ui/system";
function extractStylePropsFromObjectExpression(path, objectExpression) {
  const styledProps = {};
  const pseudoProps = {};
  const filteredProperties = objectExpression.properties?.filter((prop) => {
    if (t.isObjectProperty(prop) && t.isIdentifier(prop.key) && isStyledProp(prop.key.name)) {
      if (t.isStringLiteral(prop.value) || t.isNumericLiteral(prop.value)) {
        styledProps[prop.key.name] = prop.value.value;
      } else if (t.isIdentifier(prop.value)) {
        const binding = path.scope.getBinding(prop.value.name);
        if (binding && ["const", "let", "var"].includes(binding.kind)) {
          const declaration = binding.path.node;
          if (t.isVariableDeclarator(declaration)) {
            const init = declaration.init;
            if (t.isStringLiteral(init) || t.isNumericLiteral(init)) {
              styledProps[prop.key.name] = init.value;
            }
          }
        }
      } else if (t.isMemberExpression(prop.value)) {
        const getPropertyPath = (expr) => {
          const path2 = [];
          let currentExpr = expr;
          while (t.isMemberExpression(currentExpr)) {
            if (t.isIdentifier(currentExpr.property)) {
              path2.unshift(currentExpr.property.name);
            }
            currentExpr = currentExpr.object;
          }
          if (t.isIdentifier(currentExpr)) {
            path2.unshift(currentExpr.name);
          }
          return path2;
        };
        const dfs = (objBinding2, propertyPath2) => {
          if (!objBinding2)
            return null;
          const objDeclaration = "path" in objBinding2 ? objBinding2.path.node : objBinding2;
          if (!t.isVariableDeclarator(objDeclaration) && !t.isObjectExpression(objDeclaration)) {
            return null;
          }
          const objExpression = "init" in objDeclaration ? objDeclaration.init : objDeclaration;
          if (!t.isObjectExpression(objExpression))
            return null;
          const [nextProperty, ...remainingPath] = propertyPath2;
          for (const prop2 of objExpression.properties) {
            if (t.isObjectProperty(prop2) && t.isIdentifier(prop2.key)) {
              if (prop2.key.name === nextProperty) {
                if (remainingPath.length === 0 && t.isExpression(prop2.value)) {
                  return prop2.value;
                } else {
                  if (t.isObjectExpression(prop2.value)) {
                    return dfs(prop2.value, remainingPath);
                  } else if (t.isIdentifier(prop2.value)) {
                    const nextObjBinding = path.scope.getBinding(
                      prop2.value.name
                    );
                    return dfs(nextObjBinding, remainingPath);
                  } else {
                    return null;
                  }
                }
              }
            }
          }
          return null;
        };
        const propertyPath = getPropertyPath(prop.value);
        if (propertyPath.length === 0)
          return;
        const objBinding = path.scope.getBinding(propertyPath[0]);
        const target = dfs(objBinding, propertyPath.slice(1));
        if (target && (t.isStringLiteral(target) || t.isNumericLiteral(target))) {
          styledProps[prop.key.name] = target.value;
        }
      } else if (t.isArrayExpression(prop.value)) {
        styledProps[prop.key.name] = prop.value.elements.map((e) => {
          if (e?.type === "NumericLiteral" || e?.type === "StringLiteral") {
            return e.value;
          }
        }).filter(Boolean);
      }
      return false;
    } else if (t.isObjectProperty(prop) && t.isIdentifier(prop.key) && t.isObjectExpression(prop.value) && isPseudoProps(prop.key.name)) {
      Object.assign(pseudoProps, {
        ...pseudoProps,
        [prop.key.name]: extractStylePropsFromObjectExpression(path, prop.value).styledProps
      });
      return false;
    } else if (t.isObjectProperty(prop) && prop.key.type === "StringLiteral" && prop.key.value === "data-kuma-ui") {
      return false;
    }
    return true;
  }) || [];
  return { filteredProperties, styledProps, pseudoProps };
}

export {
  extractStylePropsFromObjectExpression
};
