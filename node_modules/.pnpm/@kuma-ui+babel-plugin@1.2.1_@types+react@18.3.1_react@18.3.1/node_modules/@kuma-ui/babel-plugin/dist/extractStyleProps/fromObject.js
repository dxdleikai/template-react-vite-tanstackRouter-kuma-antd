"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/extractStyleProps/fromObject.ts
var fromObject_exports = {};
__export(fromObject_exports, {
  extractStylePropsFromObjectExpression: () => extractStylePropsFromObjectExpression
});
module.exports = __toCommonJS(fromObject_exports);
var import_core = require("@babel/core");
var import_system = require("@kuma-ui/system");
function extractStylePropsFromObjectExpression(path, objectExpression) {
  const styledProps = {};
  const pseudoProps = {};
  const filteredProperties = objectExpression.properties?.filter((prop) => {
    if (import_core.types.isObjectProperty(prop) && import_core.types.isIdentifier(prop.key) && (0, import_system.isStyledProp)(prop.key.name)) {
      if (import_core.types.isStringLiteral(prop.value) || import_core.types.isNumericLiteral(prop.value)) {
        styledProps[prop.key.name] = prop.value.value;
      } else if (import_core.types.isIdentifier(prop.value)) {
        const binding = path.scope.getBinding(prop.value.name);
        if (binding && ["const", "let", "var"].includes(binding.kind)) {
          const declaration = binding.path.node;
          if (import_core.types.isVariableDeclarator(declaration)) {
            const init = declaration.init;
            if (import_core.types.isStringLiteral(init) || import_core.types.isNumericLiteral(init)) {
              styledProps[prop.key.name] = init.value;
            }
          }
        }
      } else if (import_core.types.isMemberExpression(prop.value)) {
        const getPropertyPath = (expr) => {
          const path2 = [];
          let currentExpr = expr;
          while (import_core.types.isMemberExpression(currentExpr)) {
            if (import_core.types.isIdentifier(currentExpr.property)) {
              path2.unshift(currentExpr.property.name);
            }
            currentExpr = currentExpr.object;
          }
          if (import_core.types.isIdentifier(currentExpr)) {
            path2.unshift(currentExpr.name);
          }
          return path2;
        };
        const dfs = (objBinding2, propertyPath2) => {
          if (!objBinding2)
            return null;
          const objDeclaration = "path" in objBinding2 ? objBinding2.path.node : objBinding2;
          if (!import_core.types.isVariableDeclarator(objDeclaration) && !import_core.types.isObjectExpression(objDeclaration)) {
            return null;
          }
          const objExpression = "init" in objDeclaration ? objDeclaration.init : objDeclaration;
          if (!import_core.types.isObjectExpression(objExpression))
            return null;
          const [nextProperty, ...remainingPath] = propertyPath2;
          for (const prop2 of objExpression.properties) {
            if (import_core.types.isObjectProperty(prop2) && import_core.types.isIdentifier(prop2.key)) {
              if (prop2.key.name === nextProperty) {
                if (remainingPath.length === 0 && import_core.types.isExpression(prop2.value)) {
                  return prop2.value;
                } else {
                  if (import_core.types.isObjectExpression(prop2.value)) {
                    return dfs(prop2.value, remainingPath);
                  } else if (import_core.types.isIdentifier(prop2.value)) {
                    const nextObjBinding = path.scope.getBinding(
                      prop2.value.name
                    );
                    return dfs(nextObjBinding, remainingPath);
                  } else {
                    return null;
                  }
                }
              }
            }
          }
          return null;
        };
        const propertyPath = getPropertyPath(prop.value);
        if (propertyPath.length === 0)
          return;
        const objBinding = path.scope.getBinding(propertyPath[0]);
        const target = dfs(objBinding, propertyPath.slice(1));
        if (target && (import_core.types.isStringLiteral(target) || import_core.types.isNumericLiteral(target))) {
          styledProps[prop.key.name] = target.value;
        }
      } else if (import_core.types.isArrayExpression(prop.value)) {
        styledProps[prop.key.name] = prop.value.elements.map((e) => {
          if (e?.type === "NumericLiteral" || e?.type === "StringLiteral") {
            return e.value;
          }
        }).filter(Boolean);
      }
      return false;
    } else if (import_core.types.isObjectProperty(prop) && import_core.types.isIdentifier(prop.key) && import_core.types.isObjectExpression(prop.value) && (0, import_system.isPseudoProps)(prop.key.name)) {
      Object.assign(pseudoProps, {
        ...pseudoProps,
        [prop.key.name]: extractStylePropsFromObjectExpression(path, prop.value).styledProps
      });
      return false;
    } else if (import_core.types.isObjectProperty(prop) && prop.key.type === "StringLiteral" && prop.key.value === "data-kuma-ui") {
      return false;
    }
    return true;
  }) || [];
  return { filteredProperties, styledProps, pseudoProps };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  extractStylePropsFromObjectExpression
});
